<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zzjxing.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Table of Contents  generated with DocToc">
<meta property="og:type" content="article">
<meta property="og:title" content="C++开发常见面试题整理（含代码题）">
<meta property="og:url" content="https://zzjxing.github.io/2023/08/15/C++%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%90%AB%E4%BB%A3%E7%A0%81%E9%A2%98%EF%BC%89/index.html">
<meta property="og:site_name" content="Hexo-zjx-blog">
<meta property="og:description" content="Table of Contents  generated with DocToc">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/7bf901f1787848d1a09ec81a4364c22b.jpeg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/396b0442be9b49e295f5f995eb52b1bf.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/9bcec54f1b024af3b1a6542c41af9e0f.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/4a9554264f464360a668cc4b2a633f3c.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/1b54459e2e6541c792b0239cf7d874c1.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/ebabbad8161d43c09af14e786df4c871.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/6d9ffd671a2a6a4ef5fbe55be1af5167.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/b921a6cb66917ab31ba529edb7e21306.jpeg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/7d0a4d878d5444e1abce99530f018015.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2cfc9fc18e144d3588dbf54e932055f2.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/8490e9ceb6c044e0ae259dd41400fef7.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200703152027423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdqaWt1ZW4=,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/639a989c851849f8bae613af4c6ba85d.png">
<meta property="article:published_time" content="2023-08-15T03:45:41.726Z">
<meta property="article:modified_time" content="2023-08-15T08:15:17.911Z">
<meta property="article:author" content="zhangjiaxing">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/7bf901f1787848d1a09ec81a4364c22b.jpeg">

<link rel="canonical" href="https://zzjxing.github.io/2023/08/15/C++%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%90%AB%E4%BB%A3%E7%A0%81%E9%A2%98%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++开发常见面试题整理（含代码题） | Hexo-zjx-blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo-zjx-blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zzjxing.github.io/2023/08/15/C++%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%90%AB%E4%BB%A3%E7%A0%81%E9%A2%98%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangjiaxing">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo-zjx-blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++开发常见面试题整理（含代码题）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-15 11:45:41 / 修改时间：16:15:17" itemprop="dateCreated datePublished" datetime="2023-08-15T11:45:41+08:00">2023-08-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong>  <em>generated with <a target="_blank" rel="noopener" href="https://github.com/thlorenz/doctoc">DocToc</a></em></p>
<span id="more"></span>

<ul>
<li><a href="#c">C++</a><ul>
<li><a href="#1-c%E5%92%8Cc%E5%8C%BA%E5%88%AB">1. C和C++区别</a></li>
<li><a href="#2-static%E5%85%B3%E9%94%AE%E5%AD%97">2. static关键字</a></li>
<li><a href="#3-cast%E8%BD%AC%E6%8D%A2">3. cast转换</a></li>
<li><a href="#4-volatile%E5%85%B3%E9%94%AE%E5%AD%97">4. volatile关键字</a></li>
<li><a href="#5-explicit">5. explicit</a></li>
<li><a href="#6-cc%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8">6. C&#x2F;C++指针和引用</a></li>
<li><a href="#7-c%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">7. C++智能指针</a></li>
<li><a href="#8-%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84">8. 指针和数组</a></li>
<li><a href="#9-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8">9. 指针和引用</a></li>
<li><a href="#10--%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0">10.  函数指针和指针函数</a></li>
<li><a href="#11-%E6%9E%90%E6%9E%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">11. 析构&amp;构造函数</a></li>
<li><a href="#12-%E9%87%8D%E8%BD%BD%E5%92%8C%E8%A6%86%E7%9B%96">12. 重载和覆盖</a></li>
<li><a href="#13-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81">13. 虚函数和多态</a></li>
<li><a href="#14-newmalloc">14. new&amp;malloc</a></li>
<li><a href="#15-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8">15. 初始化列表</a></li>
<li><a href="#16-c11">16. C++11</a></li>
<li><a href="#17-vectorarray%E6%95%B0%E7%BB%84">17. vector、array、数组</a></li>
<li><a href="#18-stdfunction-bind">18. std::function bind</a></li>
<li><a href="#19-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F">19. lambda 表达式:</a></li>
<li><a href="#20-const">20. const</a></li>
<li><a href="#21-inline%E5%92%8Cdefine">21 inline和define</a></li>
</ul>
</li>
<li><a href="#%E5%AE%B9%E5%99%A8%E5%92%8C%E7%AE%97%E6%B3%95">容器和算法</a><ul>
<li><a href="#1-map-set-%E5%8C%BA%E5%88%AB%E5%92%8C%E5%AE%9E%E7%8E%B0">1. map &amp;set 区别和实现</a></li>
<li><a href="#2-stl-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0">2. STL 迭代器删除元素</a></li>
<li><a href="#3vector-%E5%92%8C-list">3.vector 和 list</a></li>
<li><a href="#4-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%8C%87%E9%92%88">4. 迭代器、指针</a></li>
<li><a href="#5-resize-%E5%92%8C-reserve">5. resize 和 reserve</a></li>
<li><a href="#6%E6%94%BE%E5%85%A5vector%E7%B1%BB%E7%9A%84%E8%A6%81%E6%B1%82">6.放入vector类的要求</a></li>
</ul>
</li>
<li><a href="#os">OS</a><ul>
<li><a href="#1-%E5%B7%A6%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8">1. 左右值引用</a></li>
<li><a href="#2--c%E6%BA%90%E6%96%87%E4%BB%B6to%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6">2.  C++源文件to可执行文件</a></li>
<li><a href="#3%E5%A4%B4%E6%96%87%E4%BB%B6%E5%92%8C">3.头文件””和&lt;&gt;</a></li>
<li><a href="#4-malloc">4. malloc</a></li>
<li><a href="#5%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">5.程序内存管理</a></li>
<li><a href="#6%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%BA%A2%E5%87%BA">6.内存泄漏、溢出</a></li>
<li><a href="#7-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B">7. 进程与线程</a></li>
<li><a href="#8-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1">8. 进程通信</a></li>
<li><a href="#9-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1">9. 线程通信</a></li>
<li><a href="#10%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">10.虚拟内存</a></li>
<li><a href="#11%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD">11.缺页中断</a></li>
<li><a href="#12-%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C">12. 并发和并行</a></li>
<li><a href="#13-%E6%AD%BB%E9%94%81">13. 死锁</a></li>
<li><a href="#14-%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90">14. 结构体对齐</a></li>
<li><a href="#15-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2">15. 虚拟内存页面置换</a></li>
<li><a href="#16-%E9%94%81">16. 锁</a></li>
<li><a href="#17%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF">17.大端小端</a></li>
<li><a href="#18%E7%94%A8%E6%88%B7%E5%86%85%E6%A0%B8%E6%80%81">18.用户、内核态</a></li>
<li><a href="#19%E5%BE%AE%E5%86%85%E6%A0%B8-%E5%AE%8F%E5%86%85%E6%A0%B8">19.微内核 宏内核</a></li>
<li><a href="#20%E5%83%B5%E5%B0%B8%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B">20.僵尸孤儿进程</a></li>
</ul>
</li>
<li><a href="#%E7%BD%91%E7%BB%9C">网络</a><ul>
<li><a href="#1%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">1.三次握手、四次挥手</a></li>
<li><a href="#2tcp%E5%8F%AF%E9%9D%A0%E6%80%A7">2.TCP可靠性</a></li>
<li><a href="#3httphttps">3.HTTP、HTTPS</a></li>
<li><a href="#4-http-%E8%BF%94%E5%9B%9E%E7%A0%81">4. HTTP 返回码</a></li>
<li><a href="#5osi-7%E5%B1%82%E5%92%8Ctcp-4%E5%B1%82">5.OSI 7层和TCP 4层</a></li>
<li><a href="#6-url%E6%AD%A5%E9%AA%A4">6. URL步骤</a></li>
<li><a href="#7-tcpudp">7. TCP、UDP</a></li>
<li><a href="#8-socket%E5%87%BD%E6%95%B0">8. socket函数</a></li>
</ul>
</li>
<li><a href="#code-%E7%BD%91%E7%BB%9C%EF%BC%86os">code-网络＆OS</a><ul>
<li><a href="#1-%E4%B8%BB%E5%AD%90%E8%BD%AE%E6%B5%81%E8%BE%93%E5%87%BA">1. 主子轮流输出</a></li>
<li><a href="#2%E4%B8%89%E7%BA%BF%E7%A8%8B%E8%BE%93%E5%87%BAabc">2.三线程输出ABC</a></li>
</ul>
</li>
<li><a href="#%E4%BB%A3%E7%A0%81%E9%A2%98">代码题</a><ul>
<li><a href="#%E4%B8%80%E9%93%BE%E8%A1%A8">一、链表</a><ul>
<li><a href="#1-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">1. 反转链表</a><ul>
<li><a href="#1-1-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-ii">1. 1 反转链表 II</a></li>
</ul>
</li>
<li><a href="#2-k-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8">2. K 个一组翻转链表</a></li>
<li><a href="#3-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8">3. 合并两个有序链表</a></li>
<li><a href="#4-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8">4. 环形链表</a><ul>
<li><a href="#%E2%85%A1-%E8%BF%94%E5%9B%9E%E4%BA%A4%E7%82%B9">Ⅱ 返回交点</a></li>
</ul>
</li>
<li><a href="#5-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8">5. 相交链表</a></li>
<li><a href="#6-%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8">6. 合并K个有序链表</a></li>
<li><a href="#7-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8">7. 重排链表</a></li>
<li><a href="#8-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92-n-%E7%BB%93%E7%82%B9">8. 删除链表的倒 N 结点</a></li>
<li><a href="#9-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%BD%92%E5%B9%B6">9. 排序链表(归并)</a></li>
<li><a href="#10-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D">10. 排序链表去重</a><ul>
<li><a href="#101-%E5%8E%BB%E9%87%8D-ii">10.1 去重 II</a></li>
</ul>
</li>
<li><a href="#11-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9">11. 链表中倒数第k个节点</a></li>
<li><a href="#12%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8">12.回文链表</a></li>
<li><a href="#13-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-%E9%93%BE%E8%A1%A8">13 两数相加-链表</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E4%BA%8C%E5%8F%89%E6%A0%91">二、二叉树</a><ul>
<li><a href="#1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">1. 二叉树的层序遍历</a></li>
<li><a href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">2. 二叉树的最近公共祖先</a></li>
<li><a href="#3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">3. 二叉树的锯齿形层序遍历</a></li>
<li><a href="#4-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C">4. 二叉树中的最大路径和</a></li>
<li><a href="#5-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">5. 二叉树的遍历</a><ul>
<li><a href="#51-%E5%89%8D">5.1 前</a></li>
<li><a href="#52-%E4%B8%AD">5.2 中</a></li>
<li><a href="#53-%E5%90%8E">5.3 后</a></li>
</ul>
</li>
<li><a href="#6-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE">6. 二叉树的右视图</a></li>
<li><a href="#7-%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91">7. 前序与中序构造二叉树</a></li>
<li><a href="#8-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">8. 判断是否平衡二叉树</a></li>
<li><a href="#9-%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C">9. 求根节点到叶节点数字之和</a></li>
<li><a href="#10-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">10. 二叉树的最大深度</a></li>
<li><a href="#11-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91">11. 对称二叉树</a></li>
<li><a href="#12-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84">12. 二叉树的直径</a></li>
<li><a href="#13-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%E8%BF%94%E5%9B%9E%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8">13. 路径总和（返回是否存在）</a><ul>
<li><a href="#131--%E2%85%A1%E8%BF%94%E5%9B%9E%E6%89%80%E6%9C%89%E6%BB%A1%E8%B6%B3%E8%A6%81%E6%B1%82%E7%9A%84%E8%B7%AF%E5%BE%84">13.1  Ⅱ（返回所有满足要求的路径）</a></li>
</ul>
</li>
<li><a href="#14-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91">14. 翻转二叉树</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E6%95%B0%E7%BB%84">三、数组</a><ul>
<li><a href="#1-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C">1. 三数之和</a></li>
<li><a href="#2%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C">2.最大子数组和</a></li>
<li><a href="#3-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84">3. 搜索旋转排序数组</a></li>
<li><a href="#4-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA">4. 买卖股票的最佳时机</a><ul>
<li><a href="#%E2%85%A1-%E4%BB%BB%E6%84%8F%E6%AC%A1%E6%95%B0">Ⅱ 任意次数</a></li>
<li><a href="#%E2%85%A2-%E9%99%90%E5%88%B62%E6%AC%A1">Ⅲ 限制2次</a></li>
</ul>
</li>
<li><a href="#5--%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84">5.  合并两个有序数组</a></li>
<li><a href="#6--%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5">6.  螺旋矩阵</a></li>
<li><a href="#7-%E6%8E%A5%E9%9B%A8%E6%B0%B4">7. 接雨水</a></li>
<li><a href="#8-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0">8. 寻找两个正序数组的中位数</a></li>
<li><a href="#9-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4">9. 合并区间</a></li>
<li><a href="#10-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97">10. 下一个排列</a></li>
<li><a href="#11-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0">11. 缺失的第一个正数</a></li>
<li><a href="#12-%E6%B1%82%E6%95%B0%E7%BB%84%E6%89%80%E6%9C%89%E7%9A%84%E5%AD%90%E9%9B%86">12. 求数组所有的子集</a></li>
<li><a href="#13-%E5%B7%A6%E4%B8%8A-%E5%8F%B3%E4%B8%8B%E8%B7%AF%E5%BE%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84">13. 左上-&gt;右下路径最小路径</a></li>
<li><a href="#14-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F">14. 旋转图像</a></li>
<li><a href="#15%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E7%A1%AC%E5%B8%81">15.组合总和（硬币）</a></li>
<li><a href="#16-%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E5%A4%A7%E4%BA%8En2%E7%9A%84%E5%85%83%E7%B4%A0">16. 出现次数大于n&#x2F;2的元素</a></li>
<li><a href="#17--%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84">17.  最长重复子数组</a></li>
<li><a href="#18-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE">18. 在排序数组中查找元素的第一个和最后一个位置</a></li>
<li><a href="#19--%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC">19 . 寻找峰值</a></li>
<li><a href="#20-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF">20. 岛屿的最大面积</a></li>
<li><a href="#21--%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97">21.  最长连续序列</a></li>
<li><a href="#22-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84">22. 不同路径</a></li>
<li><a href="#23-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC">23. 寻找旋转排序数组中的最小值</a></li>
<li><a href="#24-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0">24. 字符串转换整数</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">四、动态规划</a><ul>
<li><a href="#1-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C">1. 最大子数组和</a></li>
<li><a href="#2-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2">2. 最长回文子串</a></li>
<li><a href="#3-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97">3. 最长递增子序列</a></li>
<li><a href="#4%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91">4.斐波那契</a></li>
<li><a href="#5-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB">5. 编辑距离</a></li>
<li><a href="#6%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97">6.最长公共子序列</a></li>
<li><a href="#7-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-%E6%9C%80%E5%B0%91">7. 零钱兑换-最少</a><ul>
<li><a href="#%E2%85%A1%E7%BB%84%E5%90%88%E6%80%BB%E6%95%B0">Ⅱ组合总数</a></li>
</ul>
</li>
<li><a href="#8-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7">8. 最长有效括号</a></li>
<li><a href="#9-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C">9. 最小路径和</a></li>
<li><a href="#10-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84">10. 最长重复子数组</a></li>
<li><a href="#11-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2">11. 最大正方形</a></li>
<li><a href="#12-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D">12. 打家劫舍</a><ul>
<li><a href="#%E2%85%A1-%E6%88%BF%E5%B1%8B%E6%98%AF%E5%9C%88">Ⅱ 房屋是圈</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%94%E5%AD%97%E7%AC%A6%E4%B8%B2">五、字符串</a><ul>
<li><a href="#1-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2">1. 无重复字符的最长子串</a></li>
<li><a href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0">2. 字符串相加</a></li>
<li><a href="#3-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90">3. 括号生成</a></li>
<li><a href="#4-%E5%A4%8D%E5%8E%9F-ip-%E5%9C%B0%E5%9D%80">4. 复原 IP 地址</a></li>
<li><a href="#5-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D">5. 反转字符串中的单词</a></li>
<li><a href="#6%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2">6.最小覆盖子串</a></li>
<li><a href="#7-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7">7. 比较版本号</a></li>
<li><a href="#8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98">8. 字符串相乘</a></li>
<li><a href="#9--%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80">9.  最长公共前缀</a></li>
<li><a href="#10-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88">10. 电话号码字母组合</a></li>
<li><a href="#11-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D">11. 字母异位词</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD%E6%8E%92%E5%BA%8F">六、排序</a><ul>
<li><a href="#1-%E6%89%8B%E6%92%95%E5%BF%AB%E6%8E%92">1. 手撕快排</a></li>
<li><a href="#2-%E5%A0%86%E6%8E%92%E5%BA%8F">2. 堆排序</a></li>
<li><a href="#3-%E5%BD%92%E5%B9%B6">3. 归并</a></li>
<li><a href="#4-%E5%86%92%E6%B3%A1">4. 冒泡</a></li>
<li><a href="#5-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">5. 选择排序</a></li>
<li><a href="#6-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">6. 插入排序</a></li>
<li><a href="#7%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">7.希尔排序</a></li>
</ul>
</li>
<li><a href="#%E5%85%AB%E5%9B%BE">八、图</a><ul>
<li><a href="#1%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95">1.迪杰斯特拉算法</a></li>
<li><a href="#2%E5%9B%BE%E4%B8%AD%E6%89%BE%E5%8D%95%E8%AF%8D">2.图中找单词</a></li>
</ul>
</li>
<li><a href="#%E4%B9%9D%E5%85%B6%E4%BB%96">九、其他</a><ul>
<li><a href="#1-lru-%E7%BC%93%E5%AD%98">1. LRU 缓存</a></li>
<li><a href="#2-%E5%85%A8%E6%8E%92%E5%88%97">2. 全排列</a></li>
<li><a href="#3-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9">3. x的平方根</a></li>
<li><a href="#4-360%E7%AC%94%E8%AF%95%E8%80%81%E5%BC%A0%E4%BF%AE%E8%B7%AF">4. 360笔试老张修路</a></li>
<li><a href="#5-360%E7%AC%94%E8%AF%95%E9%AD%94%E5%A1%94%E9%97%AF%E5%85%B3">5. 360笔试魔塔闯关</a></li>
<li><a href="#6-%E6%89%8B%E5%86%99vector">6. 手写vector</a></li>
<li><a href="#7%E6%89%8B%E5%86%99string">7.手写string</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#web%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE">web服务器项目常见面试题目</a><ul>
<li><a href="#%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D">项目介绍</a><ul>
<li><a href="#1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A%E8%BF%99%E6%A0%B7%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE">1、为什么要做这样一个项目？</a></li>
<li><a href="#2%E4%BB%8B%E7%BB%8D%E4%B8%8B%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE">2、介绍下你的项目</a></li>
<li><a href="#3%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%8A%80%E6%9C%AF%E9%9A%BE%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88">3、你的项目的技术难点是什么？</a></li>
<li><a href="#4%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%BF%99%E4%B8%AA%E6%8A%80%E6%9C%AF%E9%9A%BE%E7%82%B9%E7%9A%84">4、你是如何克服这个技术难点的？</a></li>
<li><a href="#5%E4%BD%A0%E5%81%9A%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%94%B6%E8%8E%B7%E6%98%AF%E4%BB%80%E4%B9%88">5、你做这个项目的收获是什么？</a></li>
<li><a href="#6%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E6%8A%80%E6%9C%AF%EF%BC%8F%E7%BB%84%E4%BB%B6">6、为什么使用这个技术／组件？</a></li>
<li><a href="#7%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84bug">7、如何解决项目中的BUG</a></li>
<li><a href="#8%E4%B8%BA%E4%BB%80%E4%B9%88%E6%89%80%E6%9C%89%E4%BA%BA%E9%83%BD%E6%98%AF%E8%BF%99%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE">8、为什么所有人都是这个服务器项目</a></li>
<li><a href="#9%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%89%E5%93%AA%E4%BA%9B">9、项目的异常处理有哪些</a></li>
<li><a href="#10%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%E5%8D%8F%E8%AE%AE">10、项目中用到了什么协议</a></li>
</ul>
</li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3">线程池相关</a><ul>
<li><a href="#1%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0">1、为什么使用线程池</a></li>
<li><a href="#2%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C%E9%80%BB%E8%BE%91">2、怎么创建线程池（线程池运行逻辑）</a></li>
<li><a href="#3%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B">3、线程的同步机制有哪些？</a></li>
<li><a href="#4%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%B8%80%E7%9B%B4%E7%AD%89%E5%BE%85%E5%90%97">4、线程池中的工作线程是一直等待吗？</a></li>
<li><a href="#5%E4%BD%A0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E5%AE%8C%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E5%90%8E%E7%9A%84%E7%8A%B6%E6%80%81%E6%98%AF%E4%BB%80%E4%B9%88">5、你的线程池工作线程处理完一个任务后的状态是什么？</a></li>
<li><a href="#6%E5%A6%82%E6%9E%9C%E5%90%8C%E6%97%B61000%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE%E8%AF%B7%E6%B1%82%E7%BA%BF%E7%A8%8B%E6%95%B0%E4%B8%8D%E5%A4%9A%E6%80%8E%E4%B9%88%E8%83%BD%E5%8F%8A%E6%97%B6%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%91%A2">6、如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？</a></li>
<li><a href="#7%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E5%AE%A2%E6%88%B7%E8%AF%B7%E6%B1%82%E9%9C%80%E8%A6%81%E5%8D%A0%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%BE%88%E4%B9%85%E7%9A%84%E6%97%B6%E9%97%B4%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%9A%84%E5%AE%A2%E6%88%B7%E8%AF%B7%E6%B1%82%E5%91%A2%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E7%9A%84%E7%AD%96%E7%95%A5%E5%91%A2">7、如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢?</a></li>
<li><a href="#8%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92">8、什么是虚假唤醒？</a></li>
<li><a href="#9%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%87%A0%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%9A%84%E9%94%81">9、介绍一下几种典型的锁？</a></li>
<li><a href="#10%E5%A6%82%E4%BD%95%E9%94%80%E6%AF%81%E7%BA%BF%E7%A8%8B">10、如何销毁线程</a></li>
<li><a href="#11detach%E5%92%8Cjoin%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">11、detach和join有什么区别</a></li>
<li><a href="#12%E6%AF%8F%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%8D%A0%E5%A4%9A%E5%A4%A7%E7%9A%84%E5%86%85%E5%AD%98">12、每个线程占多大的内存</a></li>
<li><a href="#13%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%95%B0%E9%87%8F%E5%A6%82%E4%BD%95%E8%AE%BE%E5%AE%9A">13、线程池中有多少个线程，线程池数量如何设定</a></li>
<li><a href="#14socket-%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B">14、socket 通信的基本流程</a></li>
<li><a href="#15listen-%E5%87%BD%E6%95%B0%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0-backlog-%E5%8F%82%E6%95%B0%E4%BD%9C%E7%94%A8">15、listen 函数第二个参数 backlog 参数作用</a></li>
<li><a href="#16listen%E5%BA%95%E5%B1%82%E7%94%A8%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E9%98%9F%E5%88%97">16、listen底层用的是什么队列</a></li>
<li><a href="#17send%E5%87%BD%E6%95%B0%E5%9C%A8%E5%8F%91%E9%80%81%E7%9A%84%E6%95%B0%E6%8D%AE%E9%95%BF%E5%BA%A6%E5%A4%A7%E4%BA%8E%E5%8F%91%E9%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F%E6%88%96%E8%80%85%E5%A4%A7%E4%BA%8E%E5%8F%91%E9%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E5%89%A9%E4%BD%99%E5%A4%A7%E5%B0%8F%E6%97%B6socket%E4%BC%9A%E6%80%8E%E4%B9%88%E5%8F%8D%E5%BA%94">17、send函数在发送的数据长度大于发送缓冲区大小，或者大于发送缓冲区剩余大小时，socket会怎么反应</a></li>
</ul>
</li>
<li><a href="#%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9B%B8%E5%85%B3">并发模型相关</a><ul>
<li><a href="#1io%E6%98%AF%E4%BB%80%E4%B9%88">1、IO是什么</a></li>
<li><a href="#2%E5%87%A0%E7%A7%8Dio%E6%A8%A1%E5%9E%8B">2、几种I&#x2F;O模型</a></li>
<li><a href="#3%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%95%88%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8Freactorproactor">3、简单说一下服务器使用的并发模型？两种高效的事件并发处理模式reactor、proactor？</a></li>
<li><a href="#4%E4%BD%A0%E7%94%A8%E4%BA%86epoll%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8epoll%E8%BF%98%E6%9C%89%E5%85%B6%E4%BB%96%E5%A4%8D%E7%94%A8%E6%96%B9%E5%BC%8F%E5%90%97%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">4、你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？</a></li>
<li><a href="#5lt%E5%92%8Cet%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">5、LT和ET的使用场景</a></li>
<li><a href="#6%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3lt%E7%9A%84%E7%BC%BA%E7%82%B9">6、怎么解决LT的缺点？</a></li>
<li><a href="#7%E4%B8%BA%E4%BB%80%E4%B9%88et%E6%A8%A1%E5%BC%8F%E4%B8%80%E5%AE%9A%E8%A6%81%E8%AE%BE%E7%BD%AE%E9%9D%9E%E9%98%BB%E5%A1%9E">7、为什么ET模式一定要设置非阻塞？</a></li>
<li><a href="#8epoll-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E5%B7%B2%E7%BB%8F%E8%AF%BB%E5%8F%96%E5%AE%8C%E6%88%90">8、epoll 如何判断数据已经读取完成</a></li>
<li><a href="#9epoll%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91">9、epoll为什么要用红黑树</a></li>
</ul>
</li>
<li><a href="#http%E6%8A%A5%E6%96%87%E8%A7%A3%E6%9E%90%E7%9B%B8%E5%85%B3">HTTP报文解析相关</a><ul>
<li><a href="#1%E7%94%A8%E4%BA%86%E7%8A%B6%E6%80%81%E6%9C%BA%E5%95%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%8A%B6%E6%80%81%E6%9C%BA">1、用了状态机啊，为什么要用状态机？</a></li>
<li><a href="#2%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E8%BD%AC%E7%A7%BB%E5%9B%BE%E7%94%BB%E4%B8%80%E4%B8%8B">2、状态机的转移图画一下</a></li>
<li><a href="#3%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E7%BC%BA%E7%82%B9">3、状态机的缺点</a></li>
<li><a href="#4https%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%89%E5%85%A8">4、HTTPS协议为什么安全？</a></li>
<li><a href="#5https%E7%9A%84ssl%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B">5、HTTPS的SSL连接过程</a></li>
<li><a href="#6get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB">6、GET和POST的区别</a></li>
<li><a href="#7http%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F">7、HTTP报文格式</a></li>
<li><a href="#8http%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95">8、HTTP常用的请求方法</a></li>
<li><a href="#9http%E7%9A%84%E5%8D%8F%E8%AE%AE%E7%89%88%E6%9C%AC">9、HTTP的协议版本</a></li>
<li><a href="#10http%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">10、HTTP常见状态码及使用场景</a></li>
<li><a href="#11http%E7%8A%B6%E6%80%81%E7%A0%81301%E5%92%8C302%E7%9A%84%E5%8C%BA%E5%88%AB">11、HTTP状态码301和302的区别</a></li>
<li><a href="#12%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4-http-%E8%AF%B7%E6%B1%82%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E6%AD%A5%E9%AA%A4">12、一次完整 HTTP 请求所经历的步骤</a></li>
<li><a href="#13http%E4%B8%8Ehttps%E7%9A%84%E7%BC%BA%E7%82%B9%E4%BB%A5%E5%8F%8A%E5%8C%BA%E5%88%AB">13、HTTP与HTTPS的缺点，以及区别</a></li>
<li><a href="#14http%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B">14、HTTP报文处理流程</a></li>
</ul>
</li>
<li><a href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9B%B8%E5%85%B3">定时器相关</a><ul>
<li><a href="#1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8">1、为什么要用定时器？</a></li>
<li><a href="#2%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">2、说一下定时器的工作原理</a></li>
<li><a href="#3%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%BB%E8%BE%91">3、定时任务处理函数的逻辑</a></li>
<li><a href="#4%E5%8D%87%E5%BA%8F%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E5%92%8C%E6%B7%BB%E5%8A%A0%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AF%B4%E4%B8%80%E4%B8%8B%E8%BF%98%E5%8F%AF%E4%BB%A5%E4%BC%98%E5%8C%96%E5%90%97">4、升序双向链表，删除和添加的时间复杂度说一下？还可以优化吗？</a><ul>
<li><a href="#5%E6%9C%80%E5%B0%8F%E5%A0%86%E4%BC%98%E5%8C%96%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">5、最小堆优化？说一下时间复杂度和工作原理</a></li>
</ul>
</li>
<li><a href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%B7%BB%E5%8A%A0ologn-%E5%88%A0%E9%99%A4o1">时间复杂度：添加：O(logn)， 删除：O(1)</a></li>
</ul>
</li>
<li><a href="#%E6%97%A5%E5%BF%97%E7%9B%B8%E5%85%B3">日志相关</a><ul>
<li><a href="#1%E8%AF%B4%E4%B8%8B%E4%BD%A0%E7%9A%84%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6">1、说下你的日志系统的运行机制？</a></li>
<li><a href="#2%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">2、为什么要异步？和同步的区别是什么？</a></li>
<li><a href="#3%E5%85%B3%E4%BA%8E%E8%AF%A5%E9%A1%B9%E7%9B%AE%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">3、关于该项目用到的设计模式</a></li>
<li><a href="#4%E7%8E%B0%E5%9C%A8%E4%BD%A0%E8%A6%81%E7%9B%91%E6%8E%A7%E4%B8%80%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%8A%B6%E6%80%81%E8%BE%93%E5%87%BA%E7%9B%91%E6%8E%A7%E6%97%A5%E5%BF%97%E8%AF%B7%E9%97%AE%E5%A6%82%E4%BD%95%E5%B0%86%E8%AF%A5%E6%97%A5%E5%BF%97%E5%88%86%E5%8F%91%E5%88%B0%E4%B8%8D%E5%90%8C%E7%9A%84%E6%9C%BA%E5%99%A8%E4%B8%8A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">4、现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上？（消息队列）</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E7%9B%B8%E5%85%B3">数据库登录注册相关</a><ul>
<li><a href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9B%E5%BB%BA%E8%BF%9E%E6%8E%A5%E6%B1%A0">1、 什么是数据库连接池，为什么要创建连接池？</a></li>
<li><a href="#2%E7%99%BB%E5%BD%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%98%AFpost%E8%AF%B7%E6%B1%82">2、登录说一下？（登录注册是POST请求）</a></li>
<li><a href="#3%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E6%80%8E%E4%B9%88%E5%86%99%E7%9A%84%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E4%BB%80%E4%B9%88">3、登录验证怎么写的？用户登录需要考虑什么？</a></li>
<li><a href="#4%E4%BD%A0%E8%BF%99%E4%B8%AA%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%E4%BA%86%E5%90%97%E5%A6%82%E6%9E%9C%E8%A6%81%E4%BF%9D%E5%AD%98%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%81%9Acookie%E5%92%8Csession">4、你这个保存状态了吗？如果要保存，你会怎么做？（cookie和session）</a></li>
<li><a href="#5%E7%99%BB%E5%BD%95%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E4%BD%A0%E6%98%AFload%E5%88%B0%E6%9C%AC%E5%9C%B0%E7%84%B6%E5%90%8E%E4%BD%BF%E7%94%A8map%E5%8C%B9%E9%85%8D%E7%9A%84%E5%A6%82%E6%9E%9C%E6%9C%8910%E4%BA%BF%E6%95%B0%E6%8D%AE%E5%8D%B3%E4%BD%BFload%E5%88%B0%E6%9C%AC%E5%9C%B0%E5%90%8Ehash%E4%B9%9F%E6%98%AF%E5%BE%88%E8%80%97%E6%97%B6%E7%9A%84%E4%BD%A0%E8%A6%81%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96">5、登录中的用户名和密码你是load到本地，然后使用map匹配的，如果有10亿数据，即使load到本地后hash，也是很耗时的，你要怎么优化？</a></li>
<li><a href="#6%E7%94%A8%E7%9A%84mysql%E5%95%8Aredis%E4%BA%86%E8%A7%A3%E5%90%97%E7%94%A8%E8%BF%87%E5%90%97">6、用的mysql啊，redis了解吗？用过吗？</a></li>
</ul>
</li>
<li><a href="#%E5%8E%8B%E6%B5%8B%E7%9B%B8%E5%85%B3">压测相关</a><ul>
<li><a href="#1%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E5%8F%91%E9%87%8F%E6%B5%8B%E8%AF%95%E8%BF%87%E5%90%97%E6%80%8E%E4%B9%88%E6%B5%8B%E8%AF%95%E7%9A%84">1、服务器并发量测试过吗？怎么测试的？</a></li>
<li><a href="#2webbench%E6%98%AF%E4%BB%80%E4%B9%88%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%8E%9F%E7%90%86">2、webbench是什么？介绍一下原理</a></li>
<li><a href="#3%E6%B5%8B%E8%AF%95%E7%9A%84%E6%97%B6%E5%80%99%E6%9C%89%E6%B2%A1%E6%9C%89%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98">3、测试的时候有没有遇到问题？</a></li>
</ul>
</li>
<li><a href="#%E7%BB%BC%E5%90%88%E8%83%BD%E5%8A%9B">综合能力</a><ul>
<li><a href="#1%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E8%A7%A3%E5%86%B3%E4%BA%86%E5%93%AA%E4%BA%9B%E5%85%B6%E4%BB%96%E5%90%8C%E7%B1%BB%E9%A1%B9%E7%9B%AE%E6%B2%A1%E6%9C%89%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98">1、你的项目解决了哪些其他同类项目没有解决的问题？</a></li>
<li><a href="#2%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%89%8D%E7%AB%AF%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E5%90%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%97%B4%E6%B6%89%E5%8F%8A%E5%93%AA%E4%BA%9B%E5%8D%8F%E8%AE%AE">2、说一下前端发送请求后，服务器处理的过程，中间涉及哪些协议？</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->

<hr>
<h2 id="title-C-开发常见面试题整理（含代码题）"><a href="#title-C-开发常见面试题整理（含代码题）" class="headerlink" title="title: C++开发常见面试题整理（含代码题）"></a>title: C++开发常见面试题整理（含代码题）</h2><p>[toc]</p>
<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="1-C和C-区别"><a href="#1-C和C-区别" class="headerlink" title="1. C和C++区别"></a>1. C和C++区别</h2><p>设计思想上：</p>
<p>​		C++是面向对象的语言，而 C 是面向过程的结构化编程语言</p>
<p>语法上：</p>
<p>​		C++具有重载、继承和多态三种特性</p>
<p>​		C++相比 C，增加多许多类型安全的功能，比如强制类型转换</p>
<p>​		C++支持范式编程，比如模板类、函数模板等</p>
<h2 id="2-static关键字"><a href="#2-static关键字" class="headerlink" title="2. static关键字"></a>2. static关键字</h2><ol>
<li><p><strong>全局静态变量</strong> </p>
<p>在全局变量前加上关键字 static，全局变量就定义成一个全局静态变量。 静态存储区，在整个程序运行期间一直存在。 初始化：未经初始化的全局静态变量会被自动初始化为 0（自动对象的值是任意的，除非他 被显式初始化）。 作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文 件结尾。 </p>
</li>
<li><p><strong>局部静态变量</strong> </p>
<p>在局部变量之前加上关键字 static，局部变量就成为一个局部静态变量。 内存中的位置：静态存储区。 初始化：未经初始化的全局静态变量会被自动初始化为 0（自动对象的值是任意的，除非他 被显式初始化）。 作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但 是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对 它进行访问，直到该函数再次被调用，并且值不变。 </p>
</li>
<li><p><strong>静态函数</strong> </p>
<p>在函数返回类型前加 static，函数就定义为静态函数。函数的定义和声明在默认情况下都 是 extern 的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。 函数的实现使用 static 修饰，那么这个函数只可在本 cpp 内使用，不会同其他 cpp 中的同 名函数引起冲突。 warning：不要再头文件中声明 static 的全局函数，不要在 cpp 内声明非 static 的全局函 数，如果你要在多个 cpp 中复用该函数，就把它的声明提到头文件里去，否则 cpp 内部声明需加 上 static 修饰。 </p>
</li>
<li><p><strong>类的静态成员</strong> </p>
<p>类的静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐 藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的 成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。</p>
</li>
<li><p><strong>类的静态函数</strong></p>
<p>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此， 对静态成员的引用不需要用对象名</p>
</li>
</ol>
<h2 id="3-cast转换"><a href="#3-cast转换" class="headerlink" title="3. cast转换"></a>3. cast转换</h2><p><strong>1、const_cast</strong></p>
<p>​		用于将 const 变量转为非 const</p>
<p><strong>2、static_cast</strong></p>
<p>​		用于各种隐式转换，比如非 const 转 const，void*转指针等, static_cast 能用于多态向上 转化，如果向下转能成功但是不安全，结果未知</p>
<p><strong>3、dynamic_cast</strong></p>
<p>​		用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指 针或引用。向下转化时，如果是非法的对于指针返回 NULL，对于引用抛异常。</p>
<p>​	    向上转换：指的是子类向基类的转换 </p>
<p>​		向下转换：指的是基类向子类的转换 </p>
<p>​		它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否 能够进行向下转换。</p>
<p><strong>4.  reinterpret_cast</strong></p>
<p>​		几乎什么都可以转，比如将 int 转指针，可能会出问题，尽量少用</p>
<h2 id="4-volatile关键字"><a href="#4-volatile关键字" class="headerlink" title="4. volatile关键字"></a>4. volatile关键字</h2><p>​		 要求每次直接从内存中读值而不是使用保存在寄存器里的备份.(易变的、不稳定的)</p>
<h2 id="5-explicit"><a href="#5-explicit" class="headerlink" title="5. explicit"></a>5. explicit</h2><p>​		explicit关键字的作用是禁止将构造函数作为转换函数。 它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式).</p>
<p>例如，如果一个类的构造函数中只包含一个整数参数，在构造函数前使用explicit关键字可以阻止像”CPerson person&#x3D;10;”这样的语句执行。</p>
<h2 id="6-C-C-指针和引用"><a href="#6-C-C-指针和引用" class="headerlink" title="6. C&#x2F;C++指针和引用"></a>6. C&#x2F;C++指针和引用</h2><p>1.指针有自己的一块空间，而引用只是一个别名； </p>
<p>2.使用 sizeof 看一个指针的大小是 4，而引用则是被引用对象的大小； </p>
<p>3.指针可以被初始化为 NULL，而引用必须被初始化且必须是一个已有对象 的引用； </p>
<p>4.作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会 改变引用所指向的对象； </p>
<p>5.可以有 const 指针，但是没有 const 引用；</p>
<p> 6.指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变； </p>
<p>7.指针可以有多级指针（**p），而引用至于一级； </p>
<p>8.指针和引用使用++运算符的意义不一样； </p>
<p>9.如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</p>
<h2 id="7-C-智能指针"><a href="#7-C-智能指针" class="headerlink" title="7. C++智能指针"></a>7. C++智能指针</h2><p>auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是 c++11 支持，并且第一个已经被 11 弃用</p>
<p>为什么要使用智能指针：</p>
<p>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释 放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类， 当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作 用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间</p>
<p><strong>1.auto_ptr</strong>（c++98 的方案，cpp11 已经抛弃）</p>
<p>采用所有权模式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt; string&gt; <span class="title">p1</span> <span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;hello world\n”)); </span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">auto_ptr p2; </span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">p2 = p1; //auto_ptr </span></span></span></span><br></pre></td></tr></table></figure>

<p>不会报错. 此时不会报错，p2 剥夺了 p1 的所有权，但是当程序运行时访问 p1 将会报错。所以 auto_ptr 的缺点是：存在潜在的内存崩溃问题</p>
<p><strong>2.unique_ptr</strong>（替换 auto_ptr)</p>
<p>unique_ptr 实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向 该对象。它对于避免资源泄露特 别有用.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt; string&gt; <span class="title">p1</span> <span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;hello world\n”)); </span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">unique_ptr p2; </span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">p2 = p1; //  报错</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">// 临时右值不会报错</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function"> unique_ptr&lt;string&gt; p3;</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">p3=unique_ptr&lt;string&gt;(new string(&quot;</span>hello world\n<span class="string">&quot;)); // 不会报错</span></span></span></span><br></pre></td></tr></table></figure>

<p><strong>3.shared_ptr</strong></p>
<p>shared_ptr 实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源 会在“最后一个引用被销毁”时候释放。从名字 share 就可以看出了资源可以被多个指针共享， 它使用计数机制来表明资源被几个指针共享。可以通过成员函数 use_count()来查看资源的所有 者个数。除了可以通过 new 来构造，还可以通过传入 unique_ptr,weak_ptr 来构造。 当我们调用 release()时，当前指针会释放资源所有权，计数减一。当计数等于 0 时，资源会被 释放.</p>
<p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使 用引用计数的机制上提供了可以共享所有权的智能指针.</p>
<p>计数原理：</p>
<p>shared_ptr的实现是这样的: shared_ptr模板类有一个shared_count类型的成员来处理引用计数的问题。shared_count也是一个模板类，它的内部有一个指向Sp_counted_base_impl类型的指针M_pi。所有引用同一个对象的shared_ptr都共用一个_M_pi指针。</p>
<p>当两个对象相互使用一个 shared_ptr 成员变量指向对方，会造成循环引用，使引用计数失 效，从而导致内存泄漏。</p>
<p><strong>4.weak_ptr</strong></p>
<p>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr 只是提供了对管理对象的一个 访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析 构不会引起引用记数的增加或减少。weak_ptr 是用来解决 shared_ptr 相互引用时的死锁问题, 如果说两个 shared_ptr 相互引用,那么这两个指针的引用计数永远不可能下降为 0,资源永远不 会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和 shared_ptr 之间可以相互转 化，shared_ptr 可以直接赋值给它，它可以通过调用 lock 函数来获得 shared_ptr.</p>
<h2 id="8-指针和数组"><a href="#8-指针和数组" class="headerlink" title="8. 指针和数组"></a>8. 指针和数组</h2><p>指针（数组）：保存数据的地址（保存数据）、间接访问数据（直接）：首先获得指针的内容，然后将其作为地址，从地址中提取数据（直接访问数据）、动态数据结构（固定数据数目和数据类型），Malloc分配和释放（隐式分配和释放）</p>
<h2 id="9-指针和引用"><a href="#9-指针和引用" class="headerlink" title="9. 指针和引用"></a>9. 指针和引用</h2><p>引用：引用就是某一变量的一个别名，对引用的操作与对变量直接操作完全一样。引用 的声明方法：类型标识符   &amp;引用名&#x3D;目标变量名；引用引入了对象的一个同义词。定义引用的表 示方法与定义指针相似，只是用&amp;代替了*。</p>
<p>指针：指针利用地址，它的值直接指向存在电脑存储器中另一个地方的值。由于通过地址能找到所 需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通 过它能找到以它为地址的内存单元。</p>
<p>区别： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">指针有自己的一块空间，而引用只是一个别名； </span><br><span class="line">使用 <span class="keyword">sizeof</span> 看一个指针的大小是 <span class="number">4</span>，而引用则是被引用对象的大小； </span><br><span class="line">指针可以被初始化为 <span class="literal">NULL</span>，而引用必须被初始化且必须是一个已有对象的引用； </span><br><span class="line">作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会 改变引用所指向的对象； </span><br><span class="line">可以有 <span class="type">const</span> 指针，但是没有 <span class="type">const</span> 引用； </span><br><span class="line">指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变； </span><br><span class="line">指针可以有多级指针（**p），而引用至于一级； </span><br><span class="line">指针和引用使用++运算符的意义不一样； </span><br><span class="line">如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</span><br></pre></td></tr></table></figure>

<h2 id="10-函数指针和指针函数"><a href="#10-函数指针和指针函数" class="headerlink" title="10.  函数指针和指针函数"></a>10.  函数指针和指针函数</h2><p>函数指针：本质上是一个指针，它指向的是一个函数的地址。</p>
<p>作用：调用函数和做函数的参数，比如回调函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span>(*p2)(<span class="type">int</span> a,<span class="type">int</span> b); <span class="comment">//函数指针是专用的。格式要求很强 返回值，参数类型，个数都必须相同。</span></span><br></pre></td></tr></table></figure>

<p>指针函数：本质上是一个函数，他的返回值是一个指针</p>
<h2 id="11-析构-构造函数"><a href="#11-析构-构造函数" class="headerlink" title="11. 析构&amp;构造函数"></a>11. 析构&amp;构造函数</h2><p><strong>构造函数</strong>：每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数]来控制其对象的初始化过程，这些函数叫做构造函数。构造函数的任务是初始化对象的数据成员，构造函数最重要的作用是创建对象本身。</p>
<p><strong>析构函数</strong>：析构函数释放对象使用的资源，并销毁对象非static数据成员。由于析构函数没有参数，所以它不能被重载。</p>
<p>一般将可能会被继承的父类的的析构函数设置为虚函数，可以保证当我们 new 一个子类，然后使用 基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p>
<p>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的 内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此 C++默认的 析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>
<p><strong>顺序</strong>：创建子类实例时，先调用父类的构造函数，再调用子类的构造函数。当要释放子类的对象时，先调用子类的析构函数，再调用父类的构造函数来销毁对象。</p>
<h2 id="12-重载和覆盖"><a href="#12-重载和覆盖" class="headerlink" title="12. 重载和覆盖"></a>12. 重载和覆盖</h2><p>重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用 域中 </p>
<p>覆盖：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是 重写</p>
<h2 id="13-虚函数和多态"><a href="#13-虚函数和多态" class="headerlink" title="13. 虚函数和多态"></a>13. 虚函数和多态</h2><ul>
<li><strong>多态</strong>的实现主要分为<strong>静态</strong>多态和<strong>动态</strong>多态，静态多态主要是<strong>重载</strong>，在<strong>编译</strong>的时候就已经确定；动 态多态是用<strong>虚函数机制</strong>实现的，在运行期间动态绑定。例如：一个父类类型的指针指向一个 子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写 过后的函数，在父类中声明为加了 virtual 关键字的函数，在子类中重写时候不需要加 virtual 也是虚函数。 </li>
<li><strong>虚函数的实现</strong>：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个 虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时 候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换 为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</li>
</ul>
<h2 id="14-new-malloc"><a href="#14-new-malloc" class="headerlink" title="14. new&amp;malloc"></a>14. new&amp;malloc</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 分配内存按照数据类型进行分配，malloc 分配内存按照指定的大小分配； </span><br><span class="line"><span class="keyword">new</span> 返回的是指定对象的指针，而 malloc 返回的是 <span class="type">void</span>*，因此 malloc 的返回值一般都 需要进行类型转化。 </span><br><span class="line"><span class="keyword">new</span> 不仅分配一段内存，而且会调用构造函数，malloc 不会。 </span><br><span class="line"><span class="keyword">new</span> 分配的内存要用 <span class="keyword">delete</span> 销毁，malloc 要用 free 来销毁；<span class="keyword">delete</span> 销毁的时候会调用 对象的析构函数，而 free 则不会。 </span><br><span class="line"><span class="keyword">new</span> 是一个操作符可以重载，malloc 是一个库函数。</span><br><span class="line">malloc 分配的内存不够的时候，可以用 realloc 扩容。扩容的原理？<span class="keyword">new</span> 没用这样操作。</span><br><span class="line"><span class="keyword">new</span> 如果分配失败了会抛出 bad_malloc 的异常，而 malloc 失败了会返回 <span class="literal">NULL</span>。 </span><br><span class="line">申请数组时： <span class="keyword">new</span>[]一次分配所有内存，多次调用构造函数，搭配使用 <span class="keyword">delete</span>[]，<span class="keyword">delete</span>[] 多次调用析构函数，销毁数组中的每个对象。而 malloc 则只能 <span class="built_in">sizeof</span>(<span class="type">int</span>) * n。</span><br></pre></td></tr></table></figure>

<h2 id="15-初始化列表"><a href="#15-初始化列表" class="headerlink" title="15. 初始化列表"></a>15. 初始化列表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当初始化的成员都是进本数据类型（<span class="type">int</span>,<span class="type">float</span>,<span class="type">char</span>等）两者的效率一样。</span><br><span class="line">当初始化成员包含类对象时，初始话列表的效率要高一些（拷贝构造函数的调用）  </span><br></pre></td></tr></table></figure>

<p>必须使用初始化列表的情况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">需要初始化的数据成员是对象的情况(这里包含了继承情况下，通过显示调用父类的构造函数对父类数据成员进行初始化)；</span><br><span class="line">需要初始化<span class="type">const</span>修饰的类成员或初始化引用成员数据；</span><br><span class="line">子类初始化父类的私有成员；</span><br><span class="line">引用数据成员</span><br></pre></td></tr></table></figure>

<h2 id="16-C-11"><a href="#16-C-11" class="headerlink" title="16. C++11"></a>16. C++11</h2><p>关键字及新语法auto nullptr </p>
<p>STL 容器 std::array  std::forward_list  std::unordered_map   std::unordered_set </p>
<p>多线程 std::thread  st::atomic  std::condition_variable </p>
<p>智能指针内存管理 std::shared_ptr std::weak_ptr</p>
<p>std::function、std::bind 封装可执行对象lamda 表达式</p>
<p>左值右值</p>
<h2 id="17-vector、array、数组"><a href="#17-vector、array、数组" class="headerlink" title="17. vector、array、数组"></a>17. vector、array、数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">数组是不安全的，array和vector是比较安全的（有效的避免越界等问题）</span><br><span class="line">array对象和数组存储在相同的内存区域（栈）中，vector对象存储在自由存储区（堆）</span><br><span class="line">array可以将一个对象赋值给另一个array对象，但是数组不行</span><br><span class="line">vector属于变长的容器，即可以根据数据的插入和删除重新构造容器容量；但是array和数组属于定长容器</span><br><span class="line">vector和array提供了更好的数据访问机制，即可以使用<span class="built_in">front</span>()和<span class="built_in">back</span>()以及<span class="built_in">at</span>()（<span class="built_in">at</span>()可以避免a[<span class="number">-1</span>]访问越界的问题）访问方式，使得访问更加安全。而数组只能通过下标访问，在写程序中很容易出现越界的错误</span><br><span class="line">vector和array提供了更好的遍历机制，即有正向迭代器和反向迭代器</span><br><span class="line">vector和array提供了<span class="built_in">size</span>()和<span class="built_in">Empty</span>()，而数组只能通过<span class="built_in">sizeof</span>()/<span class="built_in">strlen</span>()以及遍历计数来获取大小和是否为空</span><br><span class="line">vector和array提供了两个容器对象的内容交换，即<span class="built_in">swap</span>()的机制，而数组对于交换只能通过遍历的方式逐个交换元素</span><br><span class="line">array提供了初始化所有成员的方法fill（）</span><br><span class="line">由于vector的动态内存变化的机制，在插入和删除时，需要考虑迭代的是否有效问题</span><br><span class="line">vector和array在声明变量后，在声明周期完成后，会自动地释放其所占用的内存。对于数组如果用<span class="keyword">new</span>[ ]/malloc申请的空间，必须用对应的<span class="keyword">delete</span>[ ]和free来释放内存</span><br></pre></td></tr></table></figure>

<h2 id="18-std-function-bind"><a href="#18-std-function-bind" class="headerlink" title="18. std::function bind"></a>18. std::function bind</h2><p>std::function是一个<strong>函数包装模板</strong>，可以包装下列这几种可调用元素类型：函数、函数指针、类成员函数指针或任意类型的函数对象</p>
<h2 id="19-lambda-表达式"><a href="#19-lambda-表达式" class="headerlink" title="19. lambda 表达式:"></a>19. lambda 表达式:</h2><p>定义一个匿名函数，并且可以捕获一定范围内的变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[捕获列表] (函数参数) <span class="keyword">mutable</span> 或 exception 声明 -&gt; 返回值类型 &#123;函数体&#125;</span><br></pre></td></tr></table></figure>

<p>Lambda 表达式与普通函数最大的区别就是其可以通过捕获列表访问一些上下文中的数据。 其形式如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ ] 表示不捕获任何变量</span><br><span class="line">[=] 表示按值传递的方法捕获父作用域的所有变量</span><br><span class="line">[&amp;] 表示按引用传递的方法捕获父作用域的所有变量</span><br><span class="line">[=, &amp;a] 表示按值传递的方法捕获父作用域的所有变量，但按引用传递的方法捕获变量a</span><br><span class="line">[&amp;, a] 表示按引用传递的方法捕获父作用域的所有变量，但按值传递的方法捕获变量a</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算两个值的和</span></span><br><span class="line"><span class="keyword">auto</span> func = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span>&#123;<span class="keyword">return</span> a+b;&#125;;</span><br><span class="line"><span class="comment">//当返回值的类型是确定时，可以忽略返回值</span></span><br><span class="line"><span class="keyword">auto</span> func = [](<span class="type">int</span> a, <span class="type">int</span> b)&#123;<span class="keyword">return</span> a + b;&#125;;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="type">int</span> sum = <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h2 id="20-const"><a href="#20-const" class="headerlink" title="20. const"></a>20. const</h2><p><strong>左定值，右定向</strong></p>
<h2 id="21-inline和define"><a href="#21-inline和define" class="headerlink" title="21 inline和define"></a>21 inline和define</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.define</span><br><span class="line">	定义在预编译时处理的宏，只是简单的字符串替换，没有类型检查</span><br><span class="line">2.inline</span><br><span class="line">　　1.用来定义一个内联函数，引用inline的主要原因是用它替换C语言中表示式形式的宏定义；</span><br><span class="line">　　2.在编译阶段完成；</span><br><span class="line">　　3.内联函数会做类型安全检查；</span><br><span class="line">　　4.内联函数是嵌入式代码，调用内联函数时，不是跳转到内联函数执行，而是把内联函数的代码直接写到调用位置。</span><br><span class="line">　　5.inline函数仅用于短小的函数（逻辑不复杂，且一般小于10行的函数），可以提升一定的效率，和宏相比，inline函数更加安全可靠。</span><br><span class="line">　　6.缺点：增加了内存空间的消耗</span><br></pre></td></tr></table></figure>



<h1 id="容器和算法"><a href="#容器和算法" class="headerlink" title="容器和算法"></a>容器和算法</h1><h2 id="1-map-set-区别和实现"><a href="#1-map-set-区别和实现" class="headerlink" title="1. map &amp;set 区别和实现"></a>1. map &amp;set 区别和实现</h2><p>map 和 set 都是 C++的关联容器，其底层实现都是红黑树（RB-Tree）。</p>
<p>区别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map 中的元素是 key-value（关键字—值）对：关键字起到索引的作用，值则表示与索 引相关联的数据；set 与之相对就是关键字的简单集合，set 中每个元素只包含一个关键字。 </span><br><span class="line">set 的迭代器是 <span class="type">const</span> 的，不允许修改元素的值；map 允许修改 value，但不允许修改 key。其原因是因为 map 和 set 是根据关键字排序来保证其有序性的，如果允许修改 key 的话， 那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏 了 map 和 set 的结构，导致 iterator 失效，不知道应该指向改变前的位置，还是指向改变后的 位置。所以 STL 中将 set 的迭代器设置成 <span class="type">const</span>，不允许修改迭代器的值；而 map 的迭代器则不 允许修改 key 值，允许修改 value 值。 </span><br><span class="line">map 支持下标操作，set 不支持下标操作。map 可以用 key 做下标，map 的下标运算符[ ] 将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和 mapped_type 类型默认值的元素至 map 中，因此下标运算符[ ]在 map 应用中需要慎用，const_map 不能用， 只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type 类型没有默 认值也不应该使用。如果 find 能解决需要，尽可能用 find</span><br></pre></td></tr></table></figure>

<h2 id="2-STL-迭代器删除元素"><a href="#2-STL-迭代器删除元素" class="headerlink" title="2. STL 迭代器删除元素"></a>2. STL 迭代器删除元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于序列容器 vector,deque 来说，使用 <span class="built_in">erase</span>(itertor)后，后边的每个元素的迭代器都会失效，但是后边每个元素都会往前移动一个位 置，但是 erase 会返回下一个有效的迭代器；</span><br><span class="line">对于关联容器 map set 来说，使用了 <span class="built_in">erase</span>(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影 响到下一个元素的迭代器，所以在调用 erase 之前，记录下一个元素的迭代器即可。</span><br><span class="line">对于 list 来说，它使用了不连续分配的内存，并且它的 erase 方法也会返回下一个有效的 iterator，因 此上面两种正确的方法都可以使用。</span><br></pre></td></tr></table></figure>

<h2 id="3-vector-和-list"><a href="#3-vector-和-list" class="headerlink" title="3.vector 和 list"></a>3.vector 和 list</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vector::</span><br><span class="line">	连续存储的容器，动态数组，在堆上分配空间 </span><br><span class="line">	底层实现：数组</span><br><span class="line">	两倍容量增长： vector 增加（插入）新元素时，如果未超过当时的容量，则还有剩余空间，那么直接添加 到最后（插入指定位置），然后调整迭代器。 如果没有剩余空间了，则会重新配置原有元素个数的两倍空间，然后将原空间元素通过复 制的方式初始化新空间，再向新空间增加元素，最后析构并释放原空间，之前的迭代器会失效。</span><br><span class="line">List::</span><br><span class="line">	动态链表，在堆上分配空间，每插入一个元数都会分配空间，每删除一个元素都会释放空 间</span><br><span class="line">	底层：双向链表</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector 拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在 乎插入和删除的效率，使用 vector。</span><br><span class="line"> list 拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应 使用 list</span><br></pre></td></tr></table></figure>

<h2 id="4-迭代器、指针"><a href="#4-迭代器、指针" class="headerlink" title="4. 迭代器、指针"></a>4. 迭代器、指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">迭代器 Iterator，用于提供一种方法顺序访问一个聚合 对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator 模 式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况 下，按照一定顺序（由 iterator 提供的方法）访问聚合对象中的各个元素。 </span><br><span class="line">由于 Iterator 模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一 般仅用于底层聚合支持类，如 STL 的 list、vector、stack 等容器类ostream_iterator 等扩 展 iterator。</span><br></pre></td></tr></table></figure>

<p>迭代器和指针的区别</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-&gt;、*、++、--等。迭代器封装了指针，是一个“可遍历 STL容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，--等操作。迭代器返回的是对象引用而不是对象的值，所以 cout 只能输出迭代器使用*取值后的值而不能直接输出其自身</span><br></pre></td></tr></table></figure>

<h2 id="5-resize-和-reserve"><a href="#5-resize-和-reserve" class="headerlink" title="5. resize 和 reserve"></a>5. resize 和 reserve</h2><p>resize()：改变当前容器内含有元素的数量size()，例如: vector<int>v;  v.resize(len);v 的 size 变为 len,如果原来 v 的 size 小于 len，那么容器新增（len-size）个元素，元素的值为 默认为 0.当v.push_back(3);之后，则是 3 是放在了 v 的末尾，即下标为 len，此时容器是 size 为 len+1；</p>
<p>reserve()：改变当前容器的最大容量（capacity）,它不会生成元素，只是确定这个容器允许放入多少对象，如果 reserve(len)的值大于当前的 capacity()，那么会重新分配一块能存 len 个 对象的空间，然后把之前 v.size()个对象通过 copy construtor 复制过来，销毁之前的内存</p>
<h2 id="6-放入vector类的要求"><a href="#6-放入vector类的要求" class="headerlink" title="6.放入vector类的要求"></a>6.放入vector类的要求</h2><p>自定义的类必须有默认构造函数。因为vector会调用默认构造函数来初始化元素的对象。</p>
<p>数据成员中没有const和reference。因为要初始化。</p>
<h1 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h1><h2 id="1-左右值引用"><a href="#1-左右值引用" class="headerlink" title="1. 左右值引用"></a>1. 左右值引用</h2><p>概念</p>
<ul>
<li>左值：能对表达式取地址、或具名对象&#x2F;变量。一般指表达式结束后依然存在的持久对象。 </li>
<li>右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。</li>
</ul>
<p>区别</p>
<ul>
<li>左值可以寻址，而右值不可以。 </li>
<li>左值可以被赋值，右值不可以被赋值，可以用来给左值赋值</li>
<li>左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数 改变）</li>
</ul>
<p>右值引用是 C++11 中引入的新特性 。它的主要目的有两个方面：</p>
<ul>
<li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</li>
<li>能够更简洁明确地定义泛型函数。</li>
</ul>
<h2 id="2-C-源文件to可执行文件"><a href="#2-C-源文件to可执行文件" class="headerlink" title="2.  C++源文件to可执行文件"></a>2.  C++源文件to可执行文件</h2><p>对于 C++源文件，从文本到可执行文件一般需要四个过程： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和 替换，生成预编译文件。 </span><br><span class="line">编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件 </span><br><span class="line">汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件 </span><br><span class="line">链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件</span><br></pre></td></tr></table></figure>

<h2 id="3-头文件””和"><a href="#3-头文件””和" class="headerlink" title="3.头文件””和&lt;&gt;"></a>3.头文件””和&lt;&gt;</h2><p>编译器预处理阶段查找头文件的路径不一样</p>
<p>“”  查找路径：</p>
<p>当前头文件目录 $\longrightarrow$编译器设置的头文件路径 $\longrightarrow$系统变量CPLUS_INCLUDE_PATH&#x2F;C_INCLUDE_PATH 指定的头文件路径</p>
<p>&lt;&gt; 查找路径：编译器设置的头文件路径系统变量$\longrightarrow$CPLUS_INCLUDE_PATH&#x2F;C_INCLUDE_PATH 指定的头文件路径</p>
<h2 id="4-malloc"><a href="#4-malloc" class="headerlink" title="4. malloc"></a>4. malloc</h2><p>malloc() 并不是系统调用，而是 C 库里的函数，用于动态分配内存</p>
<p>malloc 申请内存的时候，会有两种方式向操作系统申请堆内存。</p>
<ul>
<li>方式一：通过 brk() 系统调用从堆分配内存</li>
<li>方式二：通过 mmap() 系统调用在文件映射区域分配内存；</li>
</ul>
<p>方式一实现的方式很简单，就是通过 brk() 函数将「堆顶」指针向高地址移动，获得新的内存空间</p>
<p>方式二通过 mmap() 系统调用中「私有匿名映射」的方式，在文件映射区分配一块内存，也就是从文件映射区“偷”了一块内存。</p>
<ul>
<li>如果用户分配的内存小于 128 KB，则通过 brk() 申请内存；</li>
<li>如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存；</li>
</ul>
<p>malloc 通过 brk() 方式申请的内存，free释放内存的时候，并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用；</p>
<p>malloc 通过 mmap() 方式申请的内存，free释放内存的时候，会把内存归还给操作系统，内存得到真正的释放。</p>
<h2 id="5-程序内存管理"><a href="#5-程序内存管理" class="headerlink" title="5.程序内存管理"></a>5.程序内存管理</h2><p><img src="https://img-blog.csdnimg.cn/7bf901f1787848d1a09ec81a4364c22b.jpeg" alt="img"></p>
<h2 id="6-内存泄漏、溢出"><a href="#6-内存泄漏、溢出" class="headerlink" title="6.内存泄漏、溢出"></a>6.内存泄漏、溢出</h2><p>内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。 内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对 该段内存的控制，因而造成了内存的浪费</p>
<p>内存泄漏的分类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过 malloc,realloc <span class="keyword">new</span> 等从堆中分配的一块内存，再是完成后必须通过调用对应的 free 或者 <span class="keyword">delete</span> 删掉。如果 程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生 Heap Leak. </span><br><span class="line">系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET 等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统 效能降低，系统运行不稳定。</span><br><span class="line">没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函 数不是 <span class="keyword">virtual</span>，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内 存泄露。</span><br></pre></td></tr></table></figure>

<p>避免：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内存泄漏通常是由于调用了 malloc/<span class="keyword">new</span> 等内存申请的操作，但是缺少了对应的 free/<span class="keyword">delete</span>。 为了判断内存是否泄露，我们一方面可以使用 linux 环境下的内存泄漏检查工具 valgrind，mtrace,另一 方面我们在写代码时可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致， 以此来判断内存是否泄露</span><br></pre></td></tr></table></figure>

<p><strong>内存溢出</strong>指程序申请内存时，没有足够的内存供申请者使用。内存溢出就是你要的内存空间超过了系统实 际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误</p>
<h2 id="7-进程与线程"><a href="#7-进程与线程" class="headerlink" title="7. 进程与线程"></a>7. 进程与线程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的 并发； 线程是进程的子任务，是 CPU 调度和分派的基本单位，用于保证程序的实时性，实现进程内 部的并发；</span><br><span class="line">线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器： 独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间 （也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源</span><br></pre></td></tr></table></figure>

<p>区别:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</span><br><span class="line">进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）</span><br><span class="line">进程是资源分配的最小单位，线程是 CPU 调度的最小单位；</span><br><span class="line">系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o 设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程 CPU 环境的保存以及新被调度运行的进程的 CPU 环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。</span><br><span class="line">通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信 IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预</span><br><span class="line">进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。</span><br><span class="line">进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉</span><br><span class="line">进程适应于多核、多机分布；线程适用于多</span><br></pre></td></tr></table></figure>

<p>多线程和多进程的不同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进程是资源分配的最小单位，而线程时 CPU 调度的最小单位。多线程之间共享同一个进程的地址空间，线程间通信简单，同步复杂，线程创建、销毁和切换简单，速度快，占用内存少，适用于多核分布式系统，但是线程间会相互影响，一个线程意外终止会导致同一个进程的其他线程也终止，程序可靠性弱。而多进程间拥有各自独立的运行地址空间，进程间不会相互影响，程序可靠性强，但是进程创建、销毁和切换复杂，速度慢，占用内存多，进程间通信复杂，但是同步简单，适用于多核、多机分布</span><br></pre></td></tr></table></figure>



<h2 id="8-进程通信"><a href="#8-进程通信" class="headerlink" title="8. 进程通信"></a>8. 进程通信</h2><p>1.管道</p>
<p>管道主要包括无名管道和命名管道:管道可用于具有亲缘关系的父子进程间的通信，有名管 道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信</p>
<p>普通管道 PIPE：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端</span><br><span class="line"><span class="number">2</span>) 它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）</span><br><span class="line"><span class="number">3</span>) 它可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read、write 等函数。但</span><br><span class="line">是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</span><br></pre></td></tr></table></figure>

<p>命名管道 FIFO：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1)FIFO 可以在无关的进程之间交换数据 </span><br><span class="line">2)FIFO 有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中</span><br></pre></td></tr></table></figure>



<p>2.系统IPC</p>
<p>消息队列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列 ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息</span></span><br><span class="line">特点:</span><br><span class="line"><span class="number">1</span>) 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</span><br><span class="line"><span class="number">2</span>) 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</span><br><span class="line"><span class="number">3</span>) 消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。</span><br></pre></td></tr></table></figure>

<p>信号量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个 进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。</span><br><span class="line">特点:</span><br><span class="line"><span class="number">1</span>) 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</span><br><span class="line"><span class="number">2</span>) 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</span><br><span class="line"><span class="number">3</span>) 每次对信号量的 PV 操作不仅限于对信号量值加 <span class="number">1</span> 或减 <span class="number">1</span>，而且可以加减任意正整数。</span><br><span class="line"><span class="number">4</span>) 支持信号量组。</span><br></pre></td></tr></table></figure>

<p>信号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</span><br></pre></td></tr></table></figure>

<p>共享内存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量</span><br><span class="line">特点：</span><br><span class="line"><span class="number">1</span>) 共享内存是最快的一种 IPC，因为进程是直接对内存进行存取</span><br><span class="line"><span class="number">2</span>) 因为多个进程可以同时操作，所以需要进行同步</span><br><span class="line"><span class="number">3</span>) 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</span><br></pre></td></tr></table></figure>

<p>3.套接字SOCKET</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket 也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信</span><br></pre></td></tr></table></figure>

<h2 id="9-线程通信"><a href="#9-线程通信" class="headerlink" title="9. 线程通信"></a>9. 线程通信</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；</span><br><span class="line">互斥量 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</span><br><span class="line">信号量 Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。</span><br><span class="line">事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</span><br></pre></td></tr></table></figure>

<h2 id="10-虚拟内存"><a href="#10-虚拟内存" class="headerlink" title="10.虚拟内存"></a>10.虚拟内存</h2><p>为了防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏，采用了虚拟内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虚拟内存技术使得不同进程在运行过程中，它所看到的是自己独自占有了当前系统的 <span class="number">4</span>G 内 存。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理 内存上。 事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体 就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和 代码（比如.text .data 段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就 好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程 运行过程中，要动态分配内存，比如 malloc 时，也只是分配了虚拟内存，即为这块虚拟内存对 应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常</span><br></pre></td></tr></table></figure>

<p>虚拟内存的好处：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">扩大地址空间；</span><br><span class="line">内存保护：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。</span><br><span class="line">公平内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。</span><br><span class="line">当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存</span><br><span class="line">虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把 CPU 交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高</span><br><span class="line">在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片</span><br></pre></td></tr></table></figure>

<p>虚拟内存的代价</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存</span><br><span class="line">虚拟地址到物理地址的转换，增加了指令的执行时间。</span><br><span class="line">页面的换入换出需要磁盘 I/O，这是很耗时的</span><br><span class="line">如果一页中只有一部分数据，会浪费内存。</span><br></pre></td></tr></table></figure>

<h2 id="11-缺页中断"><a href="#11-缺页中断" class="headerlink" title="11.缺页中断"></a>11.缺页中断</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span>()和 <span class="built_in">mmap</span>()等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配 虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一 个缺页异常。</span><br><span class="line"></span><br><span class="line">缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存 在于内存中。每当所要访问的页面不在内存是，会产生一次缺页中断，此时操作系统会根据页表 中的外存地址在外存中找到所缺的一页，将其调入内存。</span><br></pre></td></tr></table></figure>

<p>步骤</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">保护 CPU 现场 </span><br><span class="line">分析中断原因</span><br><span class="line">转入缺页中断处理程序进行处理</span><br><span class="line">恢复 CPU 现场，继续执行</span><br></pre></td></tr></table></figure>

<h2 id="12-并发和并行"><a href="#12-并发和并行" class="headerlink" title="12. 并发和并行"></a>12. 并发和并行</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核 cpu 上的多任务。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率</span><br><span class="line"></span><br><span class="line">并行（parallelism）：指严格物理意义上的同时运行，比如多核 cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的 cpu 都是往多核方面发展</span><br></pre></td></tr></table></figure>

<h2 id="13-死锁"><a href="#13-死锁" class="headerlink" title="13. 死锁"></a>13. 死锁</h2><p>死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。死锁 发生的四个必要条件如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源；</span><br><span class="line">请求和保持条件：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源</span><br><span class="line">不可剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放</span><br><span class="line">环路等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形</span><br></pre></td></tr></table></figure>

<p>解决死锁的方法即破坏上述四个条件之一，主要方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">资源一次性分配，从而剥夺请求和保持条件</span><br><span class="line">可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件</span><br><span class="line">资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条</span><br></pre></td></tr></table></figure>

<h2 id="14-结构体对齐"><a href="#14-结构体对齐" class="headerlink" title="14. 结构体对齐"></a>14. 结构体对齐</h2><p>原因</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>）平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</span><br><span class="line"><span class="number">2</span>）性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作多次内存访问；而对齐的内存访问仅需要一次访问。</span><br></pre></td></tr></table></figure>

<h2 id="15-虚拟内存页面置换"><a href="#15-虚拟内存页面置换" class="headerlink" title="15. 虚拟内存页面置换"></a>15. 虚拟内存页面置换</h2><p>FIFO，LRU，LFU，LRU-K</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FIFO（先进先出淘汰算法）</span><br><span class="line">思想：最近刚访问的，将来访问的可能性比较大。</span><br><span class="line">实现：使用一个队列，新加入的页面放入队尾，每次淘汰队首的页面，即最先进入的数据，最先被淘汰。</span><br><span class="line">弊端：无法体现页面冷热信息</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LFU（最不经常访问淘汰算法）</span><br><span class="line">思想：如果数据过去被访问多次，那么将来被访问的频率也更高。</span><br><span class="line">实现：每个数据块一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序。每次淘汰队尾数据块。</span><br><span class="line">开销：排序开销。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LRU（最近最少使用替换算法）</span><br><span class="line">思想：如果数据最近被访问过，那么将来被访问的几率也更高。</span><br><span class="line">实现：使用一个栈，新页面或者命中的页面则将该页面移动到栈底，每次替换栈顶的缓存页面。</span><br><span class="line">优点：LRU 算法对热点数据命中率是很高的。</span><br><span class="line">缺点：缓存污染，突然大量偶发性的数据访问，会让内存中存放大量冷数据</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LRU-K（LRU-2、LRU-3）</span><br><span class="line">思想：最久未使用 K 次淘汰算法。</span><br><span class="line">LRU-K 中的 K 代表最近使用的次数，因此 LRU 可以认为是 LRU-1。LRU-K 的主要目的是为了解决 LRU 算法“缓存污染”的问题，其核心思想是将“最近使用过 1 次”的判断标准扩展为“最近使用过 K 次”。</span><br><span class="line">相比 LRU，LRU-K 需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到 K 次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K 会淘汰第 K 次访问时间距当前时间最大的数据</span><br></pre></td></tr></table></figure>

<h2 id="16-锁"><a href="#16-锁" class="headerlink" title="16. 锁"></a>16. 锁</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自旋锁：spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费 CPU资源</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RCU：即 read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据 update 成新的数据。使用 RCU 时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销较大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。在有大量读操作，少量写操作的情况下效率非常高</span><br></pre></td></tr></table></figure>

<h2 id="17-大端小端"><a href="#17-大端小端" class="headerlink" title="17.大端小端"></a>17.大端小端</h2><p>大端：就是高字节排放在内存的低地址端，低字节排放在内存的高地址端。小端相反</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="built_in">check_sys</span>();</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">1</span>)	<span class="built_in">printf</span>(<span class="string">&quot;small\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span>		<span class="built_in">printf</span>(<span class="string">&quot;big\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check_sys</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="type">char</span>* p = (<span class="type">char</span>*)&amp;a;</span><br><span class="line">	<span class="keyword">if</span> (*p == <span class="number">1</span>)	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span>		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-用户、内核态"><a href="#18-用户、内核态" class="headerlink" title="18.用户、内核态"></a>18.用户、内核态</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分两种形态的原因：为了安全性。在 cpu 的一些指令中，有的指令如果用错，将会导致整个系统崩溃。分了内核态和用户态后，当用户需要操作这些指令时候，内核为其提供了 API，可以通过系统调用陷入内核，让内核去执行这些操作</span><br></pre></td></tr></table></figure>



<h2 id="19-微内核-宏内核"><a href="#19-微内核-宏内核" class="headerlink" title="19.微内核 宏内核"></a>19.微内核 宏内核</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">宏内核：除了最基本的进程、线程管理、内存管理外，将文件系统，驱动，网络协议等等 都集成在内核里面，例如 linux 内核</span><br><span class="line">优点：效率高。 </span><br><span class="line">缺点：稳定性差，开发过程中的 bug 经常会导致整个系统挂掉</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">微内核：内核中只有最基本的调度、内存管理。驱动、文件系统等都是用户态的守护进程去实现的。</span><br><span class="line">优点：稳定，驱动等的错误只会导致相应进程死掉，不会导致整个系统都崩溃</span><br><span class="line">缺点：效率低。典型代表 QNX，QNX 的文件系统是跑在用户态的进程，称为 resmgr 的东西，是订阅发布机制，文件系统的错误只会导致这个守护进程挂掉。不过数据吞吐量就比较不乐观了</span><br></pre></td></tr></table></figure>

<h2 id="20-僵尸孤儿进程"><a href="#20-僵尸孤儿进程" class="headerlink" title="20.僵尸孤儿进程"></a>20.僵尸孤儿进程</h2><p>正常进程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。 当一个进程完成它的工作终止之后，它的父进程需要调用 <span class="built_in">wait</span>()或者 <span class="built_in">waitpid</span>()系统调用取得子进程的终止状态。</span><br></pre></td></tr></table></figure>

<p>孤儿进程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被 init 进程(进程号为 <span class="number">1</span>)所收养，并由 init 进程对它们完成状态收集工作。</span><br></pre></td></tr></table></figure>

<p>僵尸进程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一个进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。</span><br><span class="line">危害：如果进程不调用 wait / waitpid 的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程</span><br><span class="line">解决：</span><br><span class="line">    外部消灭：通过 kill 发送 SIGTERM 或者 SIGKILL 信号消灭产生僵尸进程的进程，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被 init 进程接管，init 进程会 <span class="built_in">wait</span>()这些孤儿进程，释放它们占用的系统进程表中的资源</span><br><span class="line">    内部消灭：<span class="number">1.</span>子进程退出时向父进程发送 SIGCHILD 信号，父进程处理 SIGCHILD 信号。在信号处理函数中调用 wait 进行处理僵尸进程。</span><br><span class="line">    		 <span class="number">2.</span> fork 两次，原理是将子进程成为孤儿进程，从而其的父进程变为 init 进程，通过 init 进程可以处理僵尸进程。</span><br></pre></td></tr></table></figure>

<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="1-三次握手、四次挥手"><a href="#1-三次握手、四次挥手" class="headerlink" title="1.三次握手、四次挥手"></a>1.三次握手、四次挥手</h2><p><img src="https://img-blog.csdnimg.cn/396b0442be9b49e295f5f995eb52b1bf.png" alt="img"></p>
<h2 id="2-TCP可靠性"><a href="#2-TCP可靠性" class="headerlink" title="2.TCP可靠性"></a>2.TCP可靠性</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 序列号、确认应答、超时重传</span><br><span class="line">数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会 说明了它下一次需要接收的数据序列号。如果发送发迟迟未收到确认应答，那么可能是发送的数 据丢失，也可能是确认应答丢失，这时发送方在等待一定时间后会进行重传。这个时间一般是 <span class="number">2</span>*<span class="built_in">RTT</span>(报文段往返时间）+一个偏差值。</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span> 窗口控制与高速重发控制/快速重传（重复确认应答）</span><br><span class="line">TCP 会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。</span><br><span class="line">使用窗口控制，如果数据段 <span class="number">1001</span><span class="number">-2000</span> 丢失，后面数据每次传输，确认应答都会不停地发送序号为 <span class="number">1001</span> 的应答，表示我要接收 <span class="number">1001</span> 开始的数据，发送端如果收到 <span class="number">3</span> 次相同应答，就会立刻进行重发；但还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发，因为发送端知道，如果是数据段丢失，接收端不会放过它的，会疯狂向它提醒</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3. 拥塞控制</span><br><span class="line">	如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以 TCP 在为了防止这种情况而进行了拥塞控制。</span><br><span class="line">慢启动：定义拥塞窗口，一开始将该窗口大小设为 1，之后每次收到确认应答（经过一个 rtt），将拥塞窗口大小*2。</span><br><span class="line">拥塞避免：设置慢启动阈值，一般开始都设为 65536。拥塞避免是指当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是加法增加（每次确认应答/每个 rtt，拥塞窗口大小+1），以此来避免拥塞</span><br><span class="line">快速重传：在遇到 3 次重复确认应答（高速重发控制）时，代表收到了 3 个报文段，但是这之前的 1 个段丢失了，便对它进行立即重传。</span><br><span class="line">快恢复：先将阈值设为当前窗口大小的一半，然后将拥塞窗口大小设为慢启动阈值+3 的大小。</span><br></pre></td></tr></table></figure>

<h2 id="3-HTTP、HTTPS"><a href="#3-HTTP、HTTPS" class="headerlink" title="3.HTTP、HTTPS"></a>3.HTTP、HTTPS</h2><p>HTTP：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP 协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web）服务器传输超文本到本地浏览器的传送协议。</span><br><span class="line">HTTP 是一个基于 TCP/IP 通信协议来传递数据（HTML 文件，图片文件，查询结果等）</span><br><span class="line">HTTP 是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于 <span class="number">1990</span> 年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在 WWW中使用的是 HTTP/<span class="number">1.0</span> 的第六版，HTTP/<span class="number">1.1</span> 的规范化工作正在进行之中，而且 HTTP-NG（NextGeneration of HTTP）的建议已经提出</span><br><span class="line">HTTP 协议工作于客户端-服务端架构为上。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 WEB 服务器发送所有请求。Web 服务器根据接收到的请求后，向客户端发送响应信息。</span><br></pre></td></tr></table></figure>

<p>HTTP头</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">GET   /dir1/dir2/hello.html   HTTP/1.1</span><br><span class="line">Host：www.test.com</span><br><span class="line">Connection：close</span><br><span class="line">User-agent：Mozilla/5.0</span><br><span class="line">Accept-language：zh-cn</span><br><span class="line"></span><br><span class="line">1、请求行</span><br><span class="line">	请求行有三个字段：方法、URL、HTTP版本</span><br><span class="line">	（1）方法：可以取不同的值，包括GET、POST、HEAD、PUT和DELETE等。绝大部分HTTP请求报文使用GET方法。</span><br><span class="line">	（2）URL：请求对象的标识。示例中请求对象标识就是：/dir1/dir2/hello.html</span><br><span class="line">	（3）HTTP版本：略。示例中HTTP版本为1.1。</span><br><span class="line">2、首部行</span><br><span class="line">	首部行由多组键值对（首部字段名：首部字段值）组成。下面分析示例：</span><br><span class="line">	Host：指明请求对象所在主机。示例中主机为www.test.com。</span><br><span class="line">	Connection：浏览器告知服务器是否使用持续连接。示例中close代表不使用持续连接。</span><br><span class="line">	User-agent：指明用户代理，即浏览器类型。示例中浏览器类型为Mozilla/5.0。</span><br><span class="line">	Accept-language：指明用户希望得到请求对象的语言版本。示例中zh-cn代表中文版本。</span><br><span class="line">3、实体体</span><br><span class="line">	使用GET方法时，实体体为空；</span><br><span class="line">	而使用POST方法时才使用实体体，举例说明：</span><br><span class="line">	当用户提交表单时，HTTP使用POST方法，则实体体内包含的就是用户在表单的输入值。</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>HTTP版本区别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http/1.0：每个TCP连接只能发送一个请求，发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接</span><br><span class="line">http/1.1：引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用</span><br><span class="line">HTTP/2：头信息和数据体都是二进制，称为头信息帧和数据帧；复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序；允许服务器未经请求，主动向客户端发送资源，即服务器推送</span><br></pre></td></tr></table></figure>

<p>区别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP 协议和 HTTPS 协议区别如下：</span><br><span class="line"><span class="number">1.</span> HTTP 协议是以明文的方式在网络中传输数据，而 HTTPS 协议传输的数据则是经过 TLS 加密后的，HTTPS 具有更高的安全性</span><br><span class="line"><span class="number">2.</span> HTTPS 在 TCP 三次握手阶段之后，还需要进行 SSL 的 handshake，协商加密使用的对称加密密钥</span><br><span class="line"><span class="number">3.</span> HTTPS 协议需要服务端申请证书，浏览器端安装对应的根证书</span><br><span class="line"><span class="number">4.</span> HTTP 协议端口是 <span class="number">80</span>，HTTPS 协议端口是 <span class="number">443</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTPS 优点：</span><br><span class="line"><span class="number">1.</span> HTTPS 传输数据过程中使用密钥进行加密，所以安全性更高</span><br><span class="line"><span class="number">2.</span> HTTPS 协议可以认证用户和服务器，确保数据发送到正确的用户和服务器</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTPS 缺点：</span><br><span class="line"><span class="number">1.</span> HTTPS 握手阶段延时较高：由于在进行 HTTP 会话之前还需要进行 SSL 握手，因此 HTTPS 协议握手阶段延时增加</span><br><span class="line"><span class="number">2.</span> HTTPS 部署成本高：一方面 HTTPS 协议需要使用证书来验证自身的安全性，所以需要购买 CA证书；另一方面由于采用 HTTPS 协议需要进行加解密的计算，占用 CPU 资源较多，需要的服务器配置或数目高</span><br></pre></td></tr></table></figure>

<h2 id="4-HTTP-返回码"><a href="#4-HTTP-返回码" class="headerlink" title="4. HTTP 返回码"></a>4. HTTP 返回码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1xx：指示信息--表示请求已接收，继续处理。</span><br><span class="line">2xx：成功--表示请求已被成功接收、理解、接受。</span><br><span class="line">3xx：重定向--要完成请求必须进行更进一步的操作。</span><br><span class="line">4xx：客户端错误--请求有语法错误或请求无法实现。</span><br><span class="line">5xx：服务器端错误--服务器未能实现合法的请求。</span><br><span class="line">常见状态代码、状态描述的详细说明如下。</span><br><span class="line">200 OK：客户端请求成功</span><br><span class="line">206 partial content 服务器已经正确处理部分 GET 请求，实现断点续传或同时分片下载，</span><br><span class="line">该请求必须包含 Range 请求头来指示客户端期望得到的范围</span><br><span class="line">300 multiple choices（可选重定向）:被请求的资源有一系列可供选择的反馈信息，由浏</span><br><span class="line">览器/用户自行选择其中一个。</span><br><span class="line">301 moved permanently（永久重定向）：该资源已被永久移动到新位置，将来任何对该</span><br><span class="line">资源的访问都要使用本响应返回的若干个 URI 之一。</span><br><span class="line">302 move temporarily(临时重定向)：请求的资源现在临时从不同的 URI 中获得，</span><br><span class="line">304：not modified :如果客户端发送一个待条件的 GET 请求并且该请求以经被允许，而文</span><br><span class="line">档内容未被改变，则返回 304,该响应不包含包体（即可直接使用缓存）。</span><br><span class="line">403 Forbidden：服务器收到请求，但是拒绝提供服务。</span><br><span class="line">t Found：请求资源不存在，举个例子：输入了错误的 URL。</span><br></pre></td></tr></table></figure>

<h2 id="5-OSI-7层和TCP-4层"><a href="#5-OSI-7层和TCP-4层" class="headerlink" title="5.OSI 7层和TCP 4层"></a>5.OSI 7层和TCP 4层</h2><p>OSI 七层模型及其包含的协议如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">物理层: 通过媒介传输比特,确定机械及电气规范,传输单位为 bit，主要包括的协议为：IEE802<span class="number">.3</span> CLOCK RJ45</span><br><span class="line">数据链路层: 将比特组装成帧和点到点的传递,传输单位为帧,主要包括的协议为 MAC VLAN PPP</span><br><span class="line">网络层：负责数据包从源到宿的传递和网际互连，传输单位为包,主要包括的协议为 IP ARP ICMP</span><br><span class="line">传输层：提供端到端的可靠报文传递和错误恢复，传输单位为报文,主要包括的协议为 TCP UDP</span><br><span class="line">会话层：建立、管理和终止会话，传输单位为 SPDU，主要包括的协议为 RPC NFS</span><br><span class="line">表示层: 对数据进行翻译、加密和压缩,传输单位为 PPDU，主要包括的协议为 JPEG ASII</span><br><span class="line">应用层: 允许访问 OSI 环境的手段,传输单位为 APDU，主要包括的协议为 FTP HTTP DNS</span><br></pre></td></tr></table></figure>

<p>TCP&#x2F;IP四层</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">网络接口层：MAC VLAN</span><br><span class="line">网络层:IP ARP ICMP</span><br><span class="line">传输层:TCP UDP</span><br><span class="line">应用层:HTTP DNS SMT</span><br></pre></td></tr></table></figure>

<h2 id="6-URL步骤"><a href="#6-URL步骤" class="headerlink" title="6. URL步骤"></a>6. URL步骤</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">浏览器要将 URL 解析为 IP 地址，解析域名就要用到 DNS 协议，首先主机会查询 DNS 的缓存，如果没有就给本地 DNS 发送查询请求。DNS 查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的 DNS 服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的 IP 地址。DNS 服务器是基于 UDP 的，因此会用到 UDP 协议。</span><br><span class="line">得到 IP 地址后，浏览器就要与服务器建立一个 http 连接。因此要用到 http 协议，http 协议报文格式上面已经提到。http 生成一个 get 请求报文，将该报文传给 TCP 层处理，所以还会用到 TCP 协议。如果采用 https 还会使用 https 协议先对 http 数据进行加密。TCP 层如果有需要先将 HTTP 数据包分片，分片依据路径 MTU 和 MSS。TCP 的数据包然后会发送给 IP 层，用到 IP协议。IP 层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如 PPP，SLIP)，以太网协议需要直到目的 IP 地址的物理地址，有需要 ARP 协议</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> DNS 协议，http 协议，https 协议属于应用层</span><br><span class="line">	应用层是体系结构中的最高层。应用层确定进程之间通信的性质以满足用户的需要。这里的进程就是指正在运行的程序。应用层不仅要提供应用进程所需要的信息交换和远地操作，而且还要作为互相作用的应用进程的用户代理，来完成一些为进行语义上有意义的信息交换所必须的功能。应用层直接为用户的应用进程提供服务。</span><br><span class="line"><span class="number">2.</span> TCP/UDP 属于传输层</span><br><span class="line">	传输层的任务就是负责主机中两个进程之间的通信。因特网的传输层可使用两种不同协议：即面向连接的传输控制协议 TCP，和无连接的用户数据报协议 UDP。面向连接的服务能够提供可靠的交付，但无连接服务则不保证提供可靠的交付，它只是“尽最大努力交付”。这两种服务方式都很有用，备有其优缺点。在分组交换网内的各个交换结点机都没有传输层。</span><br><span class="line"><span class="number">3.</span> IP 协议，ARP 协议属于网络层</span><br><span class="line">	网络层负责为分组交换网上的不同主机提供通信。在发送数据时，网络层将运输层产生的报文段或用户数据报封装成分组或包进行传送。在 TCP/IP 体系中，分组也叫作 IP 数据报，或简称为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够交付到目的主机</span><br><span class="line"><span class="number">4.</span> 数据链路层</span><br><span class="line">	当发送数据时，数据链路层的任务是将在网络层交下来的 IP 数据报组装成帧，在两个相邻结点间的链路上传送以帧为单位的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制、以及流量控制信息等）。控制信息使接收端能够知道—个帧从哪个比特开始和到哪个比特结束。控制信息还使接收端能够检测到所收到的帧中有无差错。</span><br><span class="line"><span class="number">5.</span> 物理层</span><br><span class="line">	物理层的任务就是透明地传送比特流。在物理层上所传数据的单位是比特。传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆等，并不在物理层之内而是在物理层的下面。因此也有人把物理媒体当做第 <span class="number">0</span> 层。</span><br></pre></td></tr></table></figure>

<h2 id="7-TCP、UDP"><a href="#7-TCP、UDP" class="headerlink" title="7. TCP、UDP"></a>7. TCP、UDP</h2><p>TCP 和 UDP 区别</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 连接</span><br><span class="line">	TCP 是面向连接的传输层协议，即传输数据之前必须先建立好连接。</span><br><span class="line">	UDP 无连接。</span><br><span class="line"><span class="number">2.</span> 服务对象</span><br><span class="line">	TCP 是点对点的两点间服务，即一条 TCP 连接只能有两个端点；</span><br><span class="line">	UDP 支持一对一，一对多，多对一，多对多的交互通信。</span><br><span class="line"><span class="number">3.</span> 可靠性</span><br><span class="line">	TCP 是可靠交付：无差错，不丢失，不重复，按序到达。</span><br><span class="line">	UDP 是尽最大努力交付，不保证可靠交付。</span><br><span class="line"><span class="number">4.</span> 拥塞控制，流量控制</span><br><span class="line">	TCP 有拥塞控制和流量控制保证数据传输的安全性。</span><br><span class="line">	UDP 没有拥塞控制，网络拥塞不会影响源主机的发送效率。</span><br><span class="line"><span class="number">5.</span> 报文长度</span><br><span class="line">	TCP 是动态报文长度，即 TCP 报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。</span><br><span class="line">	UDP 面向报文，不合并，不拆分，保留上面传下来报文的边界。</span><br><span class="line"><span class="number">6.</span> 首部开销</span><br><span class="line">	TCP 首部开销大，首部 <span class="number">20</span> 个字节。</span><br><span class="line">	UDP 首部开销小，<span class="number">8</span> 字节。（源端口，目的端口，数据长度，校验和）</span><br></pre></td></tr></table></figure>

<p>TCP\UDP报文：</p>
<center class="half">
    <img src="https://img-blog.csdnimg.cn/9bcec54f1b024af3b1a6542c41af9e0f.png" width="300"/>
    <img src="https://img-blog.csdnimg.cn/4a9554264f464360a668cc4b2a633f3c.png" width="300"/>
</center>


<p>TCP 和 UDP 适用场景</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从特点上我们已经知道，TCP 是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定</span><br><span class="line">若通信数据完整性需让位与通信实时性，则应该选用 TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QQ微信发送消息过程中既有TCP参与还有UDP 同时出现P2P</span><br><span class="line">登陆成功之后，QQ都会有一个TCP连接来保持在线状态。</span><br><span class="line">QQ客户端之间的消息传送也采用了UDP模式，因为国内的网络环境非常复杂，而且很多用户采用的方式是通过代理服务器共享一条线路上网的方式，在这些复杂的情况下，客户端之间能彼此建立起来TCP连接的概率较小，严重影响传送信息的效率。而UDP包能够穿透大部分的代理服务器，因此QQ选择了UDP作为客户之间的主要通信协议。</span><br><span class="line">采用UDP协议，通过服务器中转方式。因此，现在的IP侦探在你仅仅跟对方发送聊天消息的时候是无法获取到IP的。大家都知道，UDP 协议是不可靠协议，它只管发送，不管对方是否收到的，但它的传输很高效。但是，作为聊天软件，怎么可以采用这样的不可靠方式来传输消息呢？于是，腾讯采用了上层协议来保证可靠传输：如果客户端使用UDP协议发出消息后，服务器收到该包，需要使用UDP协议发回一个应答包。如此来保证消息可以无遗漏传输。之所以会发生在客户端明明看到“消息发送失败”但对方又收到了这个消息的情况，就是因为客户端发出的消息服务器已经收到并转发成功，但客户端由于网络原因没有收到服务器的应答包引起的。</span><br><span class="line">微信采用TCP</span><br></pre></td></tr></table></figure>

<h2 id="8-socket函数"><a href="#8-socket函数" class="headerlink" title="8. socket函数"></a>8. socket函数</h2><p>TCP</p>
<p><img src="https://img-blog.csdnimg.cn/1b54459e2e6541c792b0239cf7d874c1.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">send 函数用来向 TCP 连接的另一端发送数据。客户程序一般用 send 函数向服务器发送请求，而 服务器则通常用 send 函数来向客户程序发送应答,send 的作用是将要发送的数据拷贝到缓冲区， 协议负责传输。 </span><br><span class="line">recv 函数用来从 TCP 连接的另一端接收数据，当应用程序调用 recv 函数时，recv 先等待 s 的发 送缓冲中的数据被协议传送完毕，然后从缓冲区中读取接收到的内容给应用层。 accept 函数用了接收一个连接，内核维护了半连接队列和一个已完成连接队列，当队列为空的 时候，accept 函数阻塞，不为空的时候 </span><br><span class="line">accept 函数从上边取下来一个已完成连接，返回一个文 件描述符</span><br></pre></td></tr></table></figure>

<p>UDP</p>
<p><img src="https://img-blog.csdnimg.cn/ebabbad8161d43c09af14e786df4c871.png" alt="img"></p>
<h1 id="code-网络＆OS"><a href="#code-网络＆OS" class="headerlink" title="code-网络＆OS"></a>code-网络＆OS</h1><h2 id="1-主子轮流输出"><a href="#1-主子轮流输出" class="headerlink" title="1. 主子轮流输出"></a>1. 主子轮流输出</h2><p><strong>1.子线程循环 10 次，接着主线程循环 100 次，接着又回到子线程循环 10 次，接着再回到主线程又循环 100 次，如此循环50次</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="type">pthread_attr_t</span> attr;</span><br><span class="line"><span class="type">pthread_t</span> tid;</span><br><span class="line"><span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> m_times=<span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">func</span><span class="params">(<span class="type">void</span>* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="number">2</span>*k+<span class="number">1</span>);</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond);</span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;cond,&amp;mutex);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        k++;</span><br><span class="line">        <span class="keyword">if</span>(k == m_times)    </span><br><span class="line">            <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;cond,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_attr_setdetachstate</span>(&amp;attr,PTHREAD_CREATE_DETACHED);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid,&amp;attr,func,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(flag!=<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond,&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="number">2</span>*k+<span class="number">2</span>);</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        k++;</span><br><span class="line">        <span class="keyword">if</span>(k == m_times)    </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-三线程输出ABC"><a href="#2-三线程输出ABC" class="headerlink" title="2.三线程输出ABC"></a>2.三线程输出ABC</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_attr_t</span>  attr;</span><br><span class="line"><span class="type">pthread_mutex_t</span>  mutex;</span><br><span class="line"><span class="type">pthread_cond_t</span> condA2B, condB2C, condC2A;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">pthread_t</span> tid_A, tid_B;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> flagAB, flagBC;</span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">tfnA</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        flagAB = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;condA2B);</span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;condC2A, &amp;mutex);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        k++;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">10</span>)</span><br><span class="line">            <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">tfnB</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(flagAB != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;condA2B, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        flagAB = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        flagBC = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;condB2C);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        k++;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">10</span>)</span><br><span class="line">            <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;condA2B, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;condB2C, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;condC2A, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_attr_init</span>( &amp;attr);                      <span class="comment">/*属性*/</span></span><br><span class="line">    <span class="built_in">pthread_attr_setdetachstate</span>( &amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid_A, &amp;attr, tfnA, <span class="literal">NULL</span> );</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid_B, &amp;attr, tfnB, <span class="literal">NULL</span> );</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(flagBC != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;condB2C, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        flagBC = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;condC2A);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        k++;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &quot;unpipc.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_t</span>  tidA, tidB, tidC;</span><br><span class="line"><span class="type">sem_t</span> semA, semB, semC;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">funcA</span><span class="params">(<span class="type">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">funcB</span><span class="params">(<span class="type">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">funcC</span><span class="params">(<span class="type">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;semA, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;semB, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;semC, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tidA, <span class="literal">NULL</span>, funcA, (<span class="type">void</span> *)&amp;tidA );</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tidB, <span class="literal">NULL</span>, funcB, (<span class="type">void</span> *)&amp;tidB );</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tidC, <span class="literal">NULL</span>, funcC, (<span class="type">void</span> *)&amp;tidC );</span><br><span class="line">    <span class="built_in">pthread_join</span>(tidA, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(tidB, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(tidC, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;semA);</span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;semB);</span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;semC);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">funcA</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;semA);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;semB);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">funcB</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;semB);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;semC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">funcC</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;semC);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        <span class="built_in">fflush</span>(stdout);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;semA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="代码题"><a href="#代码题" class="headerlink" title="代码题"></a>代码题</h1><h2 id="一、链表"><a href="#一、链表" class="headerlink" title="一、链表"></a>一、链表</h2><h3 id="1-反转链表"><a href="#1-反转链表" class="headerlink" title="1. 反转链表"></a>1. 反转链表</h3><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct ListNode</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     int val</span></span><br><span class="line"><span class="comment">//     ListNode *next;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>,*curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *temp = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = pre;</span><br><span class="line">            pre = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-反转链表-II"><a href="#1-1-反转链表-II" class="headerlink" title="1. 1 反转链表 II"></a>1. 1 反转链表 II</h4><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p>
<ul>
<li><pre><code class="c++">class Solution &#123;
     public:
     ListNode* reverseBetween(ListNode* head, int left, int right) &#123;
         if(left == right)
             return head;
         ListNode* newHead = new ListNode(-1);
         newHead-&gt;next=head;
         ListNode *pre=newHead,*curr,*next;
         for(int i=0;i&lt;left-1;i++)
             pre=pre-&gt;next;
         curr=pre-&gt;next;
      for(int i=0;i&lt;right-left;i++)
      &#123;
          next=curr-&gt;next;
          curr-&gt;next=next-&gt;next;
          next-&gt;next=pre-&gt;next;
          pre-&gt;next=next;
      &#125;
      return newHead-&gt;next;
     &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">### 2. K 个一组翻转链表</span><br><span class="line"></span><br><span class="line">给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。</span><br><span class="line"></span><br><span class="line">k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</span><br><span class="line"></span><br><span class="line">你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 翻转一个子链表，并且返回新的头与尾</span><br><span class="line">    pair&lt;ListNode*, ListNode*&gt; myReverse(ListNode* head, ListNode* tail) &#123;</span><br><span class="line">        ListNode* prev = tail-&gt;next;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        while (prev != tail) &#123;</span><br><span class="line">            ListNode* nex = p-&gt;next;</span><br><span class="line">            p-&gt;next = prev;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = nex;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;tail, head&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* reverseKGroup(ListNode* head, int k) &#123;</span><br><span class="line">        ListNode* hair = new ListNode(0);</span><br><span class="line">        hair-&gt;next = head;</span><br><span class="line">        ListNode* pre = hair;</span><br><span class="line">       while (head) &#123;</span><br><span class="line">           ListNode* tail = pre;</span><br><span class="line">​            // 查看剩余部分长度是否大于等于 k</span><br><span class="line">​            for (int i = 0; i &lt; k; ++i) &#123;</span><br><span class="line">​                tail = tail-&gt;next;</span><br><span class="line">​                if (!tail) &#123;</span><br><span class="line">​                    return hair-&gt;next;</span><br><span class="line">​                &#125;</span><br><span class="line">​            &#125;</span><br><span class="line">​            ListNode* nex = tail-&gt;next;</span><br><span class="line">​            // 这里是 C++17 的写法，也可以写成</span><br><span class="line">​            // pair&lt;ListNode*, ListNode*&gt; result = myReverse(head, tail);</span><br><span class="line">​            // head = result.first;</span><br><span class="line">​            // tail = result.second;</span><br><span class="line">​            tie(head, tail) = myReverse(head, tail);</span><br><span class="line">​            // 把子链表重新接回原链表</span><br><span class="line">​            pre-&gt;next = head;</span><br><span class="line">​            tail-&gt;next = nex;</span><br><span class="line">​            pre = tail;</span><br><span class="line">​            head = tail-&gt;next;</span><br><span class="line">​        &#125;</span><br><span class="line">​        return hair-&gt;next;</span><br><span class="line">​    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="3-合并两个有序链表"><a href="#3-合并两个有序链表" class="headerlink" title="3. 合并两个有序链表"></a>3. 合并两个有序链表</h3><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> list1;</span><br><span class="line"></span><br><span class="line">        ListNode *p=list1,*q=list2;</span><br><span class="line">        ListNode *rear,*head;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val&lt;q-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            head = p;</span><br><span class="line">            rear = p;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            head = q;</span><br><span class="line">            rear = q;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span> &amp;&amp; q!= <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val&lt;q-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                rear-&gt;next = p;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                rear-&gt;next = q;</span><br><span class="line">                q=q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            rear = rear-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">nullptr</span>) rear-&gt;next = q;</span><br><span class="line">        <span class="keyword">else</span> rear-&gt;next = p;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-环形链表"><a href="#4-环形链表" class="headerlink" title="4. 环形链表"></a>4. 环形链表</h3><p>给你一个链表的头节点 head ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。</p>
<p>注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *ptr1=head,*ptr2=head;</span><br><span class="line">        <span class="keyword">while</span>(ptr1!=<span class="literal">nullptr</span> &amp;&amp; ptr2!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr1 = ptr1-&gt;next;</span><br><span class="line">            ptr2 = ptr2-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(ptr2!=<span class="literal">nullptr</span>) ptr2 = ptr2-&gt;next;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(ptr1 == ptr2)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Ⅱ-返回交点"><a href="#Ⅱ-返回交点" class="headerlink" title="Ⅱ 返回交点"></a>Ⅱ 返回交点</h4><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *ptr1=head,*ptr2=head;</span><br><span class="line">        <span class="keyword">while</span>(ptr1!=<span class="literal">nullptr</span>&amp;&amp;ptr2!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr1=ptr1-&gt;next;</span><br><span class="line">            ptr2=ptr2-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(ptr2) ptr2=ptr2-&gt;next; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span>(ptr1 == ptr2)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode *ptr3=head;</span><br><span class="line">                <span class="keyword">while</span>(ptr3!=ptr1)</span><br><span class="line">                &#123;</span><br><span class="line">                    ptr1=ptr1-&gt;next;</span><br><span class="line">                    ptr3=ptr3-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr3;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-相交链表"><a href="#5-相交链表" class="headerlink" title="5. 相交链表"></a>5. 相交链表</h3><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6d9ffd671a2a6a4ef5fbe55be1af5167.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="literal">nullptr</span> || headB == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">lengthA</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">lengthB</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode *pA = headA,*pB = headB;</span><br><span class="line">        <span class="keyword">while</span>(pA)&#123;</span><br><span class="line">            lengthA++;</span><br><span class="line">            pA = pA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pB)&#123;</span><br><span class="line">            lengthB++;</span><br><span class="line">            pB = pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pA = headA;pB = headB;</span><br><span class="line">        <span class="keyword">if</span>(lengthA&gt;lengthB)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lengthA-lengthB;i++)  pA = pA-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lengthB-lengthA;i++)  pB=pB-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(pA!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pA == pB) <span class="keyword">return</span> pA;</span><br><span class="line">            pA = pA-&gt;next;</span><br><span class="line">            pB = pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-合并K个有序链表"><a href="#6-合并K个有序链表" class="headerlink" title="6. 合并K个有序链表"></a>6. 合并K个有序链表</h3><p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode *a, ListNode *b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((!a) || (!b)) <span class="keyword">return</span> a ? a : b;</span><br><span class="line">        ListNode head, *tail = &amp;head, *aPtr = a, *bPtr = b;</span><br><span class="line">        <span class="keyword">while</span> (aPtr &amp;&amp; bPtr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aPtr-&gt;val &lt; bPtr-&gt;val) &#123;</span><br><span class="line">                tail-&gt;next = aPtr; aPtr = aPtr-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = bPtr; bPtr = bPtr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail-&gt;next = (aPtr ? aPtr : bPtr);</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(vector &lt;ListNode*&gt; &amp;lists, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> lists[l];</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(<span class="built_in">merge</span>(lists, l, mid), <span class="built_in">merge</span>(lists, mid + <span class="number">1</span>, r));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(lists, <span class="number">0</span>, lists.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="7-重排链表"><a href="#7-重排链表" class="headerlink" title="7. 重排链表"></a>7. 重排链表</h3><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L0 → L1 → … → Ln - 1 → Ln</span><br></pre></td></tr></table></figure>

<p>请将其重新排列后变为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</span><br></pre></td></tr></table></figure>

<p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>||head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        vector&lt;ListNode*&gt; temp;</span><br><span class="line">        ListNode* p=head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(p);</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            temp.<span class="built_in">back</span>()-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;temp.<span class="built_in">size</span>()/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next=temp[temp.<span class="built_in">size</span>()-i<span class="number">-1</span>];p=p-&gt;next;</span><br><span class="line">            p-&gt;next=temp[i];p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="built_in">size</span>()%<span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            p-&gt;next = temp[temp.<span class="built_in">size</span>()/<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="8-删除链表的倒-N-结点"><a href="#8-删除链表的倒-N-结点" class="headerlink" title="8. 删除链表的倒 N 结点"></a>8. 删除链表的倒 N 结点</h3><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        ListNode* q=head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">             p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        q-&gt;next = q-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="9-排序链表-归并"><a href="#9-排序链表-归并" class="headerlink" title="9. 排序链表(归并)"></a>9. 排序链表(归并)</h3><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode *head1,ListNode *head2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *newHead=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *p1=head1,*p2=head2,*rear=newHead;</span><br><span class="line">        <span class="keyword">while</span>(p1 &amp;&amp; p2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p1-&gt;val&lt;p2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                rear-&gt;next=p1;</span><br><span class="line">                p1=p1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                rear-&gt;next=p2;</span><br><span class="line">                p2=p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            rear=rear-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1==<span class="literal">nullptr</span>) rear-&gt;next=p2;</span><br><span class="line">        <span class="keyword">else</span> rear-&gt;next=p1;</span><br><span class="line">        <span class="keyword">return</span> newHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *slow=head,*fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next !=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast=slow-&gt;next;</span><br><span class="line">        slow-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">sortList</span>(head),<span class="built_in">sortList</span>(fast));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="10-排序链表去重"><a href="#10-排序链表去重" class="headerlink" title="10. 排序链表去重"></a>10. 排序链表去重</h3><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="10-1-去重-II"><a href="#10-1-去重-II" class="headerlink" title="10.1 去重 II"></a>10.1 去重 II</h4><p>给定一个已排序的链表的头 <code>head</code> ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *newHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(head-&gt;val<span class="number">-1</span>);</span><br><span class="line">        newHead-&gt;next=head;</span><br><span class="line">        ListNode *curr=newHead;</span><br><span class="line">        <span class="keyword">while</span>(curr-&gt;next &amp;&amp; curr-&gt;next-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;next-&gt;val == curr-&gt;next-&gt;next-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x=curr-&gt;next-&gt;val;</span><br><span class="line">                <span class="keyword">while</span>(curr-&gt;next &amp;&amp; curr-&gt;next-&gt;val == x)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//ListNode* temp=curr-&gt;next;</span></span><br><span class="line">                    curr-&gt;next=curr-&gt;next-&gt;next;</span><br><span class="line">                    <span class="comment">//delete temp;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                curr=curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="11-链表中倒数第k个节点"><a href="#11-链表中倒数第k个节点" class="headerlink" title="11. 链表中倒数第k个节点"></a>11. 链表中倒数第k个节点</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode *p=head,*q=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="12-回文链表"><a href="#12-回文链表" class="headerlink" title="12.回文链表"></a>12.回文链表</h3><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        ListNode *ptr=head;</span><br><span class="line">        <span class="keyword">while</span>(ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            nums.<span class="built_in">push_back</span>(ptr-&gt;val);</span><br><span class="line">            ptr=ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()/<span class="number">2</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>-i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="13-两数相加-链表"><a href="#13-两数相加-链表" class="headerlink" title="13 两数相加-链表"></a>13 两数相加-链表</h3><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> add=<span class="number">0</span>;</span><br><span class="line">        ListNode *ptr1=l1,*ptr2=l2;</span><br><span class="line">        ListNode *head=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>),*rear=head;</span><br><span class="line">        <span class="keyword">while</span>(ptr1 || ptr2 || add)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x1,x2;</span><br><span class="line">            x1 = ptr1 == <span class="literal">nullptr</span>?<span class="number">0</span>:ptr1-&gt;val;</span><br><span class="line">            x2 = ptr2 == <span class="literal">nullptr</span>?<span class="number">0</span>:ptr2-&gt;val;</span><br><span class="line">            <span class="type">int</span> temp=x1+x2+add;</span><br><span class="line">            rear-&gt;next=<span class="keyword">new</span> <span class="built_in">ListNode</span>(temp%<span class="number">10</span>);</span><br><span class="line">            rear=rear-&gt;next;</span><br><span class="line">            ptr1=ptr1 == <span class="literal">nullptr</span>?ptr1:ptr1-&gt;next;</span><br><span class="line">            ptr2=ptr2 == <span class="literal">nullptr</span>?ptr2:ptr2-&gt;next;</span><br><span class="line">            add=temp/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二、二叉树"><a href="#二、二叉树" class="headerlink" title="二、二叉树"></a>二、二叉树</h2><h3 id="1-二叉树的层序遍历"><a href="#1-二叉树的层序遍历" class="headerlink" title="1. 二叉树的层序遍历"></a>1. 二叉树的层序遍历</h3><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector &lt;vector &lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        queue &lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> currentLevelSize = q.<span class="built_in">size</span>();</span><br><span class="line">            ret.<span class="built_in">push_back</span>(vector &lt;<span class="type">int</span>&gt; ());</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= currentLevelSize; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                ret.<span class="built_in">back</span>().<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-二叉树的最近公共祖先"><a href="#2-二叉树的最近公共祖先" class="headerlink" title="2. 二叉树的最近公共祖先"></a>2. 二叉树的最近公共祖先</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;TreeNode*, TreeNode*&gt; fa;</span><br><span class="line">    unordered_map&lt;TreeNode*, <span class="type">bool</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) fa[root-&gt;left] = root;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) fa[root-&gt;right] = root;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left);<span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        fa[root] = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        TreeNode* temp = p;</span><br><span class="line">        <span class="keyword">while</span>(temp)</span><br><span class="line">        &#123;</span><br><span class="line">            path[temp] = <span class="literal">true</span>;</span><br><span class="line">            temp = fa[temp];</span><br><span class="line">        &#125;</span><br><span class="line">        temp = q;</span><br><span class="line">        <span class="keyword">while</span>(temp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(path[temp]) <span class="keyword">return</span> temp;</span><br><span class="line">            temp = fa[temp];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-二叉树的锯齿形层序遍历"><a href="#3-二叉树的锯齿形层序遍历" class="headerlink" title="3. 二叉树的锯齿形层序遍历"></a>3. 二叉树的锯齿形层序遍历</h3><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b921a6cb66917ab31ba529edb7e21306.jpeg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[[3],[20,9],[15,7]]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ret;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="comment">// 是否从右到左</span></span><br><span class="line">        <span class="type">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            level++;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* t = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                temp.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(level % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                ret.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">                ret.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-二叉树中的最大路径和"><a href="#4-二叉树中的最大路径和" class="headerlink" title="4. 二叉树中的最大路径和"></a>4. 二叉树中的最大路径和</h3><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>
<p>路径和 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ret=INT_MIN;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftMax = <span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">dfs</span>(root-&gt;left));</span><br><span class="line">        <span class="type">int</span> rightMax = <span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">dfs</span>(root-&gt;right));</span><br><span class="line">        ret=<span class="built_in">max</span>(ret,leftMax+rightMax+root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val+<span class="built_in">max</span>(leftMax,rightMax);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-二叉树的遍历"><a href="#5-二叉树的遍历" class="headerlink" title="5. 二叉树的遍历"></a>5. 二叉树的遍历</h3><h4 id="5-1-前"><a href="#5-1-前" class="headerlink" title="5.1 前"></a>5.1 前</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() || node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">                stk.<span class="built_in">emplace</span>(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-2-中"><a href="#5-2-中" class="headerlink" title="5.2 中"></a>5.2 中</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-后"><a href="#5-3-后" class="headerlink" title="5.3 后"></a>5.3 后</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line">        TreeNode *prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span> || root-&gt;right == prev) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-二叉树的右视图"><a href="#6-二叉树的右视图" class="headerlink" title="6. 二叉树的右视图"></a>6. 二叉树的右视图</h3><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">levelTravel</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; qe;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        qe.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!qe.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(qe.<span class="built_in">front</span>()-&gt;val);</span><br><span class="line">            <span class="type">int</span> sizeQ = qe.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sizeQ;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp = qe.<span class="built_in">front</span>();qe.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right) qe.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left) qe.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView1</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">levelTravel</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="7-前序与中序构造二叉树"><a href="#7-前序与中序构造二叉树" class="headerlink" title="7. 前序与中序构造二叉树"></a>7. 前序与中序构造二叉树</h3><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; index;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">myBuildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder,vector&lt;<span class="type">int</span>&gt;&amp; inorder,<span class="type">int</span> preLeft,<span class="type">int</span> preRight,<span class="type">int</span> inLeft,<span class="type">int</span> inRight)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preLeft&gt;preRight) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> rootValue=preorder[preLeft];</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);</span><br><span class="line">        <span class="type">int</span> preRootIndex=preLeft;</span><br><span class="line">        <span class="type">int</span> inRootIndex=index[rootValue];</span><br><span class="line">        <span class="type">int</span> leftSize=inRootIndex-inLeft;</span><br><span class="line">        root-&gt;left=<span class="built_in">myBuildTree</span>(preorder,inorder,preLeft+<span class="number">1</span>,preLeft+leftSize,inLeft,inRootIndex<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right=<span class="built_in">myBuildTree</span>(preorder,inorder,preLeft+leftSize+<span class="number">1</span>,preRight,inRootIndex+<span class="number">1</span>,inRight);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;inorder.<span class="built_in">size</span>();i++)</span><br><span class="line">            index[inorder[i]]=i;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">myBuildTree</span>(preorder,inorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="8-判断是否平衡二叉树"><a href="#8-判断是否平衡二叉树" class="headerlink" title="8. 判断是否平衡二叉树"></a>8. 判断是否平衡二叉树</h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote>
<p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">height</span>(root-&gt;left),<span class="built_in">height</span>(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(<span class="built_in">height</span>(root-&gt;left)-<span class="built_in">height</span>(root-&gt;right))&lt;=<span class="number">1</span> &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="9-求根节点到叶节点数字之和"><a href="#9-求根节点到叶节点数字之和" class="headerlink" title="9. 求根节点到叶节点数字之和"></a>9. 求根节点到叶节点数字之和</h3><p>给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。<br>每条从根节点到叶节点的路径都代表一个数字：</p>
<p>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。<br>计算从根节点到叶节点生成的 所有数字之和 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="type">int</span> preSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum=preSum*<span class="number">10</span>+root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) <span class="keyword">return</span> sum;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">dfs</span>(root-&gt;left,sum)+<span class="built_in">dfs</span>(root-&gt;right,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="10-二叉树的最大深度"><a href="#10-二叉树的最大深度" class="headerlink" title="10. 二叉树的最大深度"></a>10. 二叉树的最大深度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root?<span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left),<span class="built_in">maxDepth</span>(root-&gt;right))+<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="11-对称二叉树"><a href="#11-对称二叉树" class="headerlink" title="11. 对称二叉树"></a>11. 对称二叉树</h3><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* p,TreeNode* q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">nullptr</span> &amp;&amp; q==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">nullptr</span>||q==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; <span class="built_in">dfs</span>(p-&gt;left,q-&gt;right) &amp;&amp; <span class="built_in">dfs</span>(q-&gt;left,p-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root,root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="12-二叉树的直径"><a href="#12-二叉树的直径" class="headerlink" title="12. 二叉树的直径"></a>12. 二叉树的直径</h3><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftDepth=<span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightDepth=<span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,rightDepth+leftDepth+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(rightDepth,leftDepth)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ans=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="13-路径总和（返回是否存在）"><a href="#13-路径总和（返回是否存在）" class="headerlink" title="13. 路径总和（返回是否存在）"></a>13. 路径总和（返回是否存在）</h3><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        target -=root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; target == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root-&gt;left,target) || <span class="built_in">dfs</span>(root-&gt;right,target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root,targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="13-1-Ⅱ（返回所有满足要求的路径）"><a href="#13-1-Ⅱ（返回所有满足要求的路径）" class="headerlink" title="13.1  Ⅱ（返回所有满足要求的路径）"></a>13.1  Ⅱ（返回所有满足要求的路径）</h4><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        target-=root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; target==<span class="number">0</span>)</span><br><span class="line">            ret.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left,target);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right,target);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> targetSum) &#123;</span><br><span class="line">       <span class="built_in">dfs</span>(root,targetSum);</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="14-翻转二叉树"><a href="#14-翻转二叉树" class="headerlink" title="14. 翻转二叉树"></a>14. 翻转二叉树</h3><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="三、数组"><a href="#三、数组" class="headerlink" title="三、数组"></a>三、数组</h2><h3 id="1-三数之和"><a href="#1-三数之和" class="headerlink" title="1. 三数之和"></a>1. 三数之和</h3><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。请</p>
<p>你返回所有和为 0 且不重复的三元组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// -4 -1 -1 0 1 2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> left = i+<span class="number">1</span>,right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[left] + nums[right] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i],nums[left],nums[right]&#125;);</span><br><span class="line">                    left++;right--;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;nums.<span class="built_in">size</span>() &amp;&amp; nums[left] == nums[left<span class="number">-1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span>(right&gt;<span class="number">0</span> &amp;&amp; nums[right] == nums[right+<span class="number">1</span>]) right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-最大子数组和"><a href="#2-最大子数组和" class="headerlink" title="2.最大子数组和"></a>2.最大子数组和</h3><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong> 是数组中的一个连续部分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = INT_MIN;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        result = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>]+nums[i],nums[i]);</span><br><span class="line">            result = <span class="built_in">max</span>(result,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-搜索旋转排序数组"><a href="#3-搜索旋转排序数组" class="headerlink" title="3. 搜索旋转排序数组"></a>3. 搜索旋转排序数组</h3><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p>
<p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>] &lt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 左半段</span></span><br><span class="line">            <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> rightValue = nums[right]&gt;=nums[<span class="number">0</span>]?nums[right]:INT_MAX;</span><br><span class="line">                <span class="type">int</span> midValue = nums[mid]&gt;=nums[<span class="number">0</span>]?nums[mid]:INT_MAX;</span><br><span class="line">                <span class="keyword">if</span>(midValue == target) <span class="keyword">return</span> mid;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(midValue &lt; target) left = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 右半段</span></span><br><span class="line">            <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> leftValue = nums[left]&lt;=nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>]?nums[left]:INT_MIN;</span><br><span class="line">                <span class="type">int</span> midValue = nums[mid]&lt;=nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>]?nums[mid]:INT_MIN;</span><br><span class="line">                <span class="keyword">if</span>(midValue == target) <span class="keyword">return</span> mid;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(midValue&lt;target) left = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-买卖股票的最佳时机"><a href="#4-买卖股票的最佳时机" class="headerlink" title="4. 买卖股票的最佳时机"></a>4. 买卖股票的最佳时机</h3><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftMin = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            leftMin = <span class="built_in">min</span>(prices[i],leftMin);</span><br><span class="line">            ret = <span class="built_in">max</span>(ret,prices[i]-leftMin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Ⅱ-任意次数"><a href="#Ⅱ-任意次数" class="headerlink" title="Ⅱ 任意次数"></a>Ⅱ 任意次数</h4><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p>
<p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p>
<p>返回 你能获得的 最大 利润 。</p>
<p>思路：</p>
<p>dp(i)(0)表示第 ii 天交易完后手里没有股票的最大利润,dp(i)(1)表示第 ii 天交易完后手里持有一支股票的最大利润</p>
<p>dp(i)(0)&#x3D;max{dp(i-1)(0),dp(i-1)(1)+<em>prices</em>[<em>i</em>]}</p>
<p>dp(i)(1)&#x3D;max{dp(i-1)(1),dp(i-1)(0)−<em>prices</em>[<em>i</em>]}</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dp[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Ⅲ-限制2次"><a href="#Ⅲ-限制2次" class="headerlink" title="Ⅲ 限制2次"></a>Ⅲ 限制2次</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftMin=prices[<span class="number">0</span>],rightMax=prices[prices.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">// dp_1[i]: 第0-i天的最大利润  prices[i]-leftmin</span></span><br><span class="line">        <span class="comment">// dp_2[i]: 第i-n天的最大利润  rightMax-prices[i]</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp_1</span><span class="params">(prices.size(),<span class="number">0</span>)</span></span>;   </span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp_2</span><span class="params">(prices.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp_1[<span class="number">0</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp_1[i]=<span class="built_in">max</span>(dp_1[i<span class="number">-1</span>],prices[i]-leftMin);</span><br><span class="line">            leftMin=<span class="built_in">min</span>(leftMin,prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=prices.<span class="built_in">size</span>()<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp_2[i]=<span class="built_in">max</span>(dp_2[i+<span class="number">1</span>],rightMax-prices[i]);</span><br><span class="line">            rightMax=<span class="built_in">max</span>(prices[i],rightMax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            ret = <span class="built_in">max</span>(dp_1[i<span class="number">-1</span>]+dp_2[i], ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp_1[prices.<span class="built_in">size</span>()<span class="number">-1</span>], ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="5-合并两个有序数组"><a href="#5-合并两个有序数组" class="headerlink" title="5.  合并两个有序数组"></a>5.  合并两个有序数组</h3><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p>
<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>) nums1 = nums2;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">p1</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">p2</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p1 == m || p2 == n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums1[p1] &lt; nums2[p2])</span><br><span class="line">            &#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(nums1[p1]);</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(nums2[p2]);</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1 == m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(p2;p2&lt;n;p2++) ret.<span class="built_in">push_back</span>(nums2[p2]);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(p1;p1&lt;m;p1++) ret.<span class="built_in">push_back</span>(nums1[p1]);</span><br><span class="line">        &#125;</span><br><span class="line">        nums1 = ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-螺旋矩阵"><a href="#6-螺旋矩阵" class="headerlink" title="6.  螺旋矩阵"></a>6.  螺旋矩阵</h3><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="type">int</span> t=<span class="number">0</span>,b=matrix.<span class="built_in">size</span>()<span class="number">-1</span>,l=<span class="number">0</span>,r=matrix[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++) ret.<span class="built_in">push_back</span>(matrix[t][i]);</span><br><span class="line">            t++;<span class="keyword">if</span>(t&gt;b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=t;i&lt;=b;i++) ret.<span class="built_in">push_back</span>(matrix[i][r]);</span><br><span class="line">            r--;<span class="keyword">if</span>(l&gt;r) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=r;i&gt;=l;i--) ret.<span class="built_in">push_back</span>(matrix[b][i]);</span><br><span class="line">            b--;<span class="keyword">if</span>(t&gt;b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=b;i&gt;=t;i--) ret.<span class="built_in">push_back</span>(matrix[i][l]);</span><br><span class="line">            l++;<span class="keyword">if</span>(l&gt;r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="7-接雨水"><a href="#7-接雨水" class="headerlink" title="7. 接雨水"></a>7. 接雨水</h3><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftMax</span><span class="params">(height.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightMax</span><span class="params">(height.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        leftMax[<span class="number">0</span>]=height[<span class="number">0</span>];</span><br><span class="line">        rightMax[height.<span class="built_in">size</span>()<span class="number">-1</span>] = height[height.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;height.<span class="built_in">size</span>();i++)</span><br><span class="line">            leftMax[i]=<span class="built_in">max</span>(height[i],leftMax[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=height.<span class="built_in">size</span>()<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            rightMax[i]=<span class="built_in">max</span>(height[i],rightMax[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;height.<span class="built_in">size</span>();i++)   </span><br><span class="line">            ans+=(<span class="built_in">min</span>(leftMax[i],rightMax[i])-height[i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="8-寻找两个正序数组的中位数"><a href="#8-寻找两个正序数组的中位数" class="headerlink" title="8. 寻找两个正序数组的中位数"></a>8. 寻找两个正序数组的中位数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getKthElement</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class="line"><span class="comment">         * 这里的 &quot;/&quot; 表示整除</span></span><br><span class="line"><span class="comment">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class="line"><span class="comment">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span></span><br><span class="line"><span class="comment">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 边界情况</span></span><br><span class="line">            <span class="keyword">if</span> (index1 == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 正常情况</span></span><br><span class="line">            <span class="type">int</span> newIndex1 = <span class="built_in">min</span>(index1 + k / <span class="number">2</span> - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> newIndex2 = <span class="built_in">min</span>(index2 + k / <span class="number">2</span> - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> pivot1 = nums1[newIndex1];</span><br><span class="line">            <span class="type">int</span> pivot2 = nums2[newIndex2];</span><br><span class="line">            <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">                k -= newIndex1 - index1 + <span class="number">1</span>;</span><br><span class="line">                index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= newIndex2 - index2 + <span class="number">1</span>;</span><br><span class="line">                index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> totalLength = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getKthElement</span>(nums1, nums2, (totalLength + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> (<span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span>) + <span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="9-合并区间"><a href="#9-合并区间" class="headerlink" title="9. 合并区间"></a>9. 合并区间</h3><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> L=intervals[<span class="number">0</span>][<span class="number">0</span>],R=intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;intervals.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&gt;R)  </span><br><span class="line">            &#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(&#123;L,R&#125;);</span><br><span class="line">                L=intervals[i][<span class="number">0</span>];</span><br><span class="line">                R=intervals[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            R=<span class="built_in">max</span>(R,intervals[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        ret.<span class="built_in">push_back</span>(&#123;L,R&#125;);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="10-下一个排列"><a href="#10-下一个排列" class="headerlink" title="10. 下一个排列"></a>10. 下一个排列</h3><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p>
<p>例如，arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。<br>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<p>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。<br>类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。</p>
<p><strong>思路：</strong></p>
<ul>
<li><p>首先从后向前查找第一个顺序对 (i,i+1)(i,i+1)，满足 a[i] &lt; a[i+1]a[i]&lt;a[i+1]。这样「较小数」即为 a[i]a[i]。此时 [i+1,n)[i+1,n) 必然是下降序列。</p>
</li>
<li><p>如果找到了顺序对，那么在区间 [i+1,n)[i+1,n) 中从后向前查找第一个元素 jj 满足 a[i] &lt; a[j]a[i]&lt;a[j]。这样「较大数」即为 a[j]a[j]。</p>
</li>
<li><p>交换 a[i]a[i] 与 a[j]a[j]，此时可以证明区间 [i+1,n)[i+1,n) 必为降序。我们可以直接使用双指针反转区间 [i+1,n)[i+1,n) 使其变为升序，而无需对该区间进行排序。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span> || nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; nums[i]&gt;=nums[i+<span class="number">1</span>])</span><br><span class="line">            i--;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">-1</span> &amp;&amp; nums[<span class="number">0</span>]&gt;=nums[<span class="number">1</span>]) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;nums[i]&gt;=nums[j])</span><br><span class="line">            j--;</span><br><span class="line">        <span class="built_in">swap</span>(nums[j],nums[i]);</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>()+i+<span class="number">1</span>,nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="11-缺失的第一个正数"><a href="#11-缺失的第一个正数" class="headerlink" title="11. 缺失的第一个正数"></a>11. 缺失的第一个正数</h3><p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p>
<p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;=<span class="number">0</span>) nums[i]=nums.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num=<span class="built_in">abs</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(num&lt;=nums.<span class="built_in">size</span>()) nums[num<span class="number">-1</span>]=-<span class="built_in">abs</span>(nums[num<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) </span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="12-求数组所有的子集"><a href="#12-求数组所有的子集" class="headerlink" title="12. 求数组所有的子集"></a>12. 求数组所有的子集</h3><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hashmap;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backTrace</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,vector&lt;<span class="type">int</span>&gt;&amp; path,<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ret.<span class="built_in">push_back</span>(path);        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hashmap[nums[i]] == <span class="number">1</span> ) <span class="keyword">continue</span>;</span><br><span class="line">            hashmap[nums[i]]=<span class="number">1</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backTrace</span>(nums,path,index+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            hashmap[nums[i]]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        res.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; temp=res;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;temp.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                temp[j].<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                res.<span class="built_in">push_back</span>(temp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="13-左上-右下路径最小路径"><a href="#13-左上-右下路径最小路径" class="headerlink" title="13. 左上-&gt;右下路径最小路径"></a>13. 左上-&gt;右下路径最小路径</h3><p>给定一个包含非负整数的 <code>m x n</code>网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;  <span class="built_in">dp</span>(grid.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(grid[<span class="number">0</span>].<span class="built_in">size</span>(),<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;grid.<span class="built_in">size</span>();i++)</span><br><span class="line">            dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;grid[<span class="number">0</span>].<span class="built_in">size</span>();j++)</span><br><span class="line">            dp[<span class="number">0</span>][j]=dp[<span class="number">0</span>][j<span class="number">-1</span>]+grid[<span class="number">0</span>][j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;grid.<span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;grid[<span class="number">0</span>].<span class="built_in">size</span>();j++)</span><br><span class="line">            dp[i][j]=<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j])+grid[i][j];</span><br><span class="line">        <span class="keyword">return</span> dp[grid.<span class="built_in">size</span>()<span class="number">-1</span>][grid[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="14-旋转图像"><a href="#14-旋转图像" class="headerlink" title="14. 旋转图像"></a>14. 旋转图像</h3><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(matrix.<span class="built_in">size</span>()+<span class="number">1</span>)/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;matrix[<span class="number">0</span>].<span class="built_in">size</span>()/<span class="number">2</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> temp=matrix[i][j];</span><br><span class="line">                matrix[i][j]=matrix[matrix.<span class="built_in">size</span>()-j<span class="number">-1</span>][i];</span><br><span class="line">                matrix[matrix.<span class="built_in">size</span>()-j<span class="number">-1</span>][i]=matrix[matrix.<span class="built_in">size</span>()-i<span class="number">-1</span>][matrix.<span class="built_in">size</span>()-j<span class="number">-1</span>];</span><br><span class="line">                matrix[matrix.<span class="built_in">size</span>()-i<span class="number">-1</span>][matrix.<span class="built_in">size</span>()-j<span class="number">-1</span>]=matrix[j][matrix.<span class="built_in">size</span>()-i<span class="number">-1</span>];</span><br><span class="line">                matrix[j][matrix.<span class="built_in">size</span>()-i<span class="number">-1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="15-组合总和（硬币）"><a href="#15-组合总和（硬币）" class="headerlink" title="15.组合总和（硬币）"></a>15.组合总和（硬币）</h3><p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p>
<p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates,vector&lt;<span class="type">int</span>&gt; path, <span class="type">int</span> target,<span class="type">int</span> begin)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=begin;i&lt;candidates.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates,path,target-candidates[i],i);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) </span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates,path,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="16-出现次数大于n-2的元素"><a href="#16-出现次数大于n-2的元素" class="headerlink" title="16. 出现次数大于n&#x2F;2的元素"></a>16. 出现次数大于n&#x2F;2的元素</h3><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> count=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == res)</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                count--;</span><br><span class="line">            <span class="keyword">if</span>(count&lt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res=nums[i];</span><br><span class="line">                count=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="17-最长重复子数组"><a href="#17-最长重复子数组" class="headerlink" title="17.  最长重复子数组"></a>17.  最长重复子数组</h3><p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度</em> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(A.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(B.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=B.<span class="built_in">size</span>()<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=A[i]==B[j]?dp[i+<span class="number">1</span>][j+<span class="number">1</span>]+<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="18-在排序数组中查找元素的第一个和最后一个位置"><a href="#18-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="18. 在排序数组中查找元素的第一个和最后一个位置"></a>18. 在排序数组中查找元素的第一个和最后一个位置</h3><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ret</span><span class="params">(<span class="number">2</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> middle=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle]==target)</span><br><span class="line">            &#123;</span><br><span class="line">                ret[<span class="number">1</span>]=middle;</span><br><span class="line">                left=middle+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[middle]&gt;target)</span><br><span class="line">            &#123;</span><br><span class="line">                right=middle<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left=middle+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left=<span class="number">0</span>;right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> middle=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle]==target)</span><br><span class="line">            &#123;</span><br><span class="line">                ret[<span class="number">0</span>]=middle;</span><br><span class="line">                right=middle<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[middle]&gt;target)</span><br><span class="line">            &#123;</span><br><span class="line">                right=middle<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left=middle+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="19-寻找峰值"><a href="#19-寻找峰值" class="headerlink" title="19 . 寻找峰值"></a>19 . 寻找峰值</h3><p>峰值元素是指其值严格大于左右相邻值的元素。</p>
<p>给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</p>
<p>你可以假设 nums[-1] &#x3D; nums[n] &#x3D; -∞ 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPeakElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> m = (l+r) / <span class="number">2</span>;</span><br><span class="line">            nums[m] &lt; nums[m+<span class="number">1</span>] ? l = m + <span class="number">1</span> : r = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="20-岛屿的最大面积"><a href="#20-岛屿的最大面积" class="headerlink" title="20. 岛屿的最大面积"></a>20. 岛屿的最大面积</h3><p>给你一个大小为 m x n 的二进制矩阵 grid 。</p>
<p>岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p>
<p>岛屿的面积是岛上值为 1 的单元格的数目。</p>
<p>计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;grid,<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j]==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        grid[i][j]=<span class="number">0</span>;<span class="comment">//每次统计后置0</span></span><br><span class="line">        <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;grid[i<span class="number">-1</span>][j]==<span class="number">1</span>)res+=<span class="built_in">dfs</span>(grid,i<span class="number">-1</span>,j);</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>&lt;=grid.<span class="built_in">size</span>()<span class="number">-1</span>&amp;&amp;grid[i+<span class="number">1</span>][j]==<span class="number">1</span>)res+=<span class="built_in">dfs</span>(grid,i+<span class="number">1</span>,j);</span><br><span class="line">        <span class="keyword">if</span>(j<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;grid[i][j<span class="number">-1</span>]==<span class="number">1</span>)res+=<span class="built_in">dfs</span>(grid,i,j<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span>&lt;=grid[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>&amp;&amp;grid[i][j+<span class="number">1</span>]==<span class="number">1</span>)res+=<span class="built_in">dfs</span>(grid,i,j+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> Max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;grid.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].<span class="built_in">size</span>();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                  Max=<span class="built_in">max</span>(Max,<span class="built_in">dfs</span>(grid,i,j));  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="21-最长连续序列"><a href="#21-最长连续序列" class="headerlink" title="21.  最长连续序列"></a>21.  最长连续序列</h3><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; num_set;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; num : nums) &#123;</span><br><span class="line">            num_set.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> longestStreak = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span>&amp; num : num_set) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!num_set.<span class="built_in">count</span>(num - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="type">int</span> currentNum = num;</span><br><span class="line">                <span class="type">int</span> currentStreak = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (num_set.<span class="built_in">count</span>(currentNum + <span class="number">1</span>)) &#123;</span><br><span class="line">                    currentNum += <span class="number">1</span>;</span><br><span class="line">                    currentStreak += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                longestStreak = <span class="built_in">max</span>(longestStreak, currentStreak);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longestStreak;           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="22-不同路径"><a href="#22-不同路径" class="headerlink" title="22. 不同路径"></a>22. 不同路径</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p><strong>思路一：排列组合</strong></p>
<p>因为机器到底右下角，向下几步，向右几步都是固定的，</p>
<p>比如，m&#x3D;3, n&#x3D;2，我们只要向下 1 步，向右 2 步就一定能到达终点。</p>
<p>所以有 $C_{m+n-2}^{m-1}$种方案</p>
<p><strong>思路二：动态规划</strong></p>
<p>我们令 dp[i][j] 是到达 i, j 最多路径</p>
<p>动态方程：dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1]</p>
<p>注意，对于第一行 dp[0][j]，或者第一列 dp[i][0]，由于都是在边界，所以只能为 1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            f[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j] + f[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="23-寻找旋转排序数组中的最小值"><a href="#23-寻找旋转排序数组中的最小值" class="headerlink" title="23. 寻找旋转排序数组中的最小值"></a>23. 寻找旋转排序数组中的最小值</h3><p>已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums &#x3D; [0,1,2,4,5,6,7] 在变化后可能得到：<br>若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]<br>若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> high = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">int</span> pivot = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[pivot] &lt; nums[high]) &#123;</span><br><span class="line">                high = pivot;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                low = pivot + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="24-字符串转换整数"><a href="#24-字符串转换整数" class="headerlink" title="24. 字符串转换整数"></a>24. 字符串转换整数</h3><p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C&#x2F;C++ 中的 <code>atoi</code> 函数）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret=<span class="number">0</span>,isFu=<span class="number">1</span>;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// if(s[i]&gt;=&#x27;0&#x27; &amp;&amp; s[i]&lt;=&#x27;9&#x27;&amp;&amp;isEnd==true) return 0;</span></span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;-&#x27;</span> || s[i] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                isFu=s[i] == <span class="string">&#x27;-&#x27;</span>?<span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;0&#x27;</span> || s[i] == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;1&#x27;</span> &amp;&amp; s[i]&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i]&lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(ret&gt;=INT_MAX/<span class="number">10</span>) <span class="keyword">return</span> isFu==<span class="number">1</span>?isFu * (INT_MAX):isFu * (<span class="number">1L</span>+INT_MAX);</span><br><span class="line">                    ret=ret*<span class="number">10</span>;</span><br><span class="line">                    <span class="keyword">if</span>(ret&gt;=INT_MAX-(s[i]-<span class="string">&#x27;0&#x27;</span>)) <span class="keyword">return</span> isFu==<span class="number">1</span>?isFu * (INT_MAX):isFu * (<span class="number">1L</span>+INT_MAX);</span><br><span class="line">                    ret=ret+s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// isEnd=true;</span></span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==s.<span class="built_in">size</span>() || i&lt;s.<span class="built_in">size</span>() &amp;&amp; s[i] == <span class="string">&#x27;.&#x27;</span> || s[<span class="number">0</span>]&gt;=<span class="string">&#x27;1&#x27;</span> &amp;&amp; s[<span class="number">0</span>]&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> isFu*ret;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="四、动态规划"><a href="#四、动态规划" class="headerlink" title="四、动态规划"></a>四、动态规划</h2><h3 id="1-最大子数组和"><a href="#1-最大子数组和" class="headerlink" title="1. 最大子数组和"></a>1. 最大子数组和</h3><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = INT_MIN;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        result = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>]+nums[i],nums[i]);</span><br><span class="line">            result = <span class="built_in">max</span>(result,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-最长回文子串"><a href="#2-最长回文子串" class="headerlink" title="2. 最长回文子串"></a>2. 最长回文子串</h3><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">expandAroundCenter</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.<span class="built_in">size</span>() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;left + <span class="number">1</span>, right - <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [left1, right1] = <span class="built_in">expandAroundCenter</span>(s, i, i);</span><br><span class="line">            <span class="keyword">auto</span> [left2, right2] = <span class="built_in">expandAroundCenter</span>(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (right1 - left1 &gt; end - start) &#123;</span><br><span class="line">                start = left1;</span><br><span class="line">                end = right1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right2 - left2 &gt; end - start) &#123;</span><br><span class="line">                start = left2;</span><br><span class="line">                end = right2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, end - start + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-最长递增子序列"><a href="#3-最长递增子序列" class="headerlink" title="3. 最长递增子序列"></a>3. 最长递增子序列</h3><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">ret</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(),<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i]=<span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret=<span class="built_in">max</span>(ret,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-斐波那契"><a href="#4-斐波那契" class="headerlink" title="4.斐波那契"></a>4.斐波那契</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> sqrt5 = <span class="built_in">sqrt</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="type">double</span> fibn = <span class="built_in">pow</span>((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n + <span class="number">1</span>) - <span class="built_in">pow</span>((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)<span class="built_in">round</span>(fibn / sqrt5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-编辑距离"><a href="#5-编辑距离" class="headerlink" title="5. 编辑距离"></a>5. 编辑距离</h3><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li><p>插入一个字符</p>
</li>
<li><p>删除一个字符</p>
</li>
<li><p>替换一个字符</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=word1.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> m=word2.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(n*m == <span class="number">0</span>) <span class="keyword">return</span> n+m;</span><br><span class="line">        <span class="comment">// dp[i][j] 表示 A 的前 i 个字母和 B 的前 j 个字母之间的编辑距离。</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">            dp[i][<span class="number">0</span>]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m+<span class="number">1</span>;j++)</span><br><span class="line">            dp[<span class="number">0</span>][j]=j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;m+<span class="number">1</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> left=dp[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> up=dp[i][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> left_up=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(word1[i<span class="number">-1</span>]!=word2[j<span class="number">-1</span>]) left_up++;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(left_up,<span class="built_in">min</span>(left,up));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-最长公共子序列"><a href="#6-最长公共子序列" class="headerlink" title="6.最长公共子序列"></a>6.最长公共子序列</h3><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(text1.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(text2.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;dp.<span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;dp[<span class="number">0</span>].<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>])</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[text1.<span class="built_in">size</span>()][text2.<span class="built_in">size</span>()];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="7-零钱兑换-最少"><a href="#7-零钱兑换-最少" class="headerlink" title="7. 零钱兑换-最少"></a>7. 零钱兑换-最少</h3><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> Max=amount+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 15  8</span></span><br><span class="line">        <span class="comment">// dp[15]=min(dp[15-2],dp[15-3],dp[15-4])+1</span></span><br><span class="line">        <span class="comment">// dp[15] dp[0]=0 dp[1]=MAX dp[2..7]=MAX dp[8]=dp[8-0]+1=1 dp[9...15]=dp[1...7]+1=MAX+1</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>,Max)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=amount;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;coins.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(coins[j]&lt;=i)</span><br><span class="line">                    dp[i]=<span class="built_in">min</span>(dp[i],dp[i-coins[j]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount]&gt;amount?<span class="number">-1</span>:dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Ⅱ组合总数"><a href="#Ⅱ组合总数" class="headerlink" title="Ⅱ组合总数"></a>Ⅱ组合总数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>&amp; coin : coins) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = coin; i &lt;= amount; i++) &#123;</span><br><span class="line">                dp[i] += dp[i - coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="8-最长有效括号"><a href="#8-最长有效括号" class="headerlink" title="8. 最长有效括号"></a>8. 最长有效括号</h3><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(length,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                dp[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i<span class="number">-2</span>&gt;=<span class="number">0</span>)</span><br><span class="line">                        dp[i]=dp[i<span class="number">-2</span>]+<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[i]=<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i-dp[i<span class="number">-1</span>]&gt;<span class="number">0</span> &amp;&amp; s[i-dp[i<span class="number">-1</span>]<span class="number">-1</span>] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(i-dp[i<span class="number">-1</span>]<span class="number">-2</span>&gt;=<span class="number">0</span>)</span><br><span class="line">                            dp[i]=dp[i-dp[i<span class="number">-1</span>]<span class="number">-2</span>]+dp[i<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            dp[i]=dp[i<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="9-最小路径和"><a href="#9-最小路径和" class="headerlink" title="9. 最小路径和"></a>9. 最小路径和</h3><p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;  <span class="built_in">dp</span>(grid.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(grid[<span class="number">0</span>].<span class="built_in">size</span>(),<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;grid.<span class="built_in">size</span>();i++)</span><br><span class="line">            dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;grid[<span class="number">0</span>].<span class="built_in">size</span>();j++)</span><br><span class="line">            dp[<span class="number">0</span>][j]=dp[<span class="number">0</span>][j<span class="number">-1</span>]+grid[<span class="number">0</span>][j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;grid.<span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;grid[<span class="number">0</span>].<span class="built_in">size</span>();j++)</span><br><span class="line">            dp[i][j]=<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j])+grid[i][j];</span><br><span class="line">        <span class="keyword">return</span> dp[grid.<span class="built_in">size</span>()<span class="number">-1</span>][grid[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="10-最长重复子数组"><a href="#10-最长重复子数组" class="headerlink" title="10. 最长重复子数组"></a>10. 最长重复子数组</h3><p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度</em> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(A.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(B.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=B.<span class="built_in">size</span>()<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=A[i]==B[j]?dp[i+<span class="number">1</span>][j+<span class="number">1</span>]+<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="11-最大正方形"><a href="#11-最大正方形" class="headerlink" title="11. 最大正方形"></a>11. 最大正方形</h3><p>在一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的二维矩阵内，找到只包含 <code>&#39;1&#39;</code> 的最大正方形，并返回其面积。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=matrix.<span class="built_in">size</span>(),n=matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=matrix[i][<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            res=<span class="built_in">max</span>(dp[i][<span class="number">0</span>],res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j]=matrix[<span class="number">0</span>][j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            res=<span class="built_in">max</span>(dp[<span class="number">0</span>][j],res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>],<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]))+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res=<span class="built_in">max</span>(res,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res*res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="12-打家劫舍"><a href="#12-打家劫舍" class="headerlink" title="12. 打家劫舍"></a>12. 打家劫舍</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p> $\textit{dp}[i] $表示前 i间房屋能偷窃到的最高总金额，那么就有如下的状态转移方程:</p>
<p>$dp[i]&#x3D;max(dp[i−2]+nums[i],dp[i−1])$</p>
<p>边界条件：</p>
<p><strong>dp[0]&#x3D;nums[0]</strong> </p>
<p><strong>dp[1]&#x3D;max(nums[0],nums[1])</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dp = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(size, <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; size; i++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Ⅱ-房屋是圈"><a href="#Ⅱ-房屋是圈" class="headerlink" title="Ⅱ 房屋是圈"></a>Ⅱ 房屋是圈</h4><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p>
<p>两种情况：1. 在1~n-1范围内盗窃  2. 在2-2范围内盗窃  返回两种方案的最大值即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">robRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> first = nums[start], second = <span class="built_in">max</span>(nums[start], nums[start + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start + <span class="number">2</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = second;</span><br><span class="line">            second = <span class="built_in">max</span>(first + nums[i], second);</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (length == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">robRange</span>(nums, <span class="number">0</span>, length - <span class="number">2</span>), <span class="built_in">robRange</span>(nums, <span class="number">1</span>, length - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="五、字符串"><a href="#五、字符串" class="headerlink" title="五、字符串"></a>五、字符串</h2><h3 id="1-无重复字符的最长子串"><a href="#1-无重复字符的最长子串" class="headerlink" title="1. 无重复字符的最长子串"></a>1. 无重复字符的最长子串</h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p>双指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">pos1</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">pos2</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">res</span><span class="params">(<span class="number">-1</span>)</span>,<span class="title">nowLength</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; set;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.<span class="built_in">find</span>(s[pos2]) == set.<span class="built_in">end</span>() &amp;&amp; pos2 != s.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                set.<span class="built_in">insert</span>(s[pos2]);</span><br><span class="line">                pos2++;</span><br><span class="line">                nowLength++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                set.<span class="built_in">erase</span>(s[pos1]);</span><br><span class="line">                res = res&lt;nowLength?nowLength:res;</span><br><span class="line">                nowLength--;</span><br><span class="line">                pos1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pos1 == s.<span class="built_in">size</span>() ||  pos2 == s.<span class="built_in">size</span>())</span><br><span class="line">                <span class="keyword">return</span> nowLength&gt;res?nowLength:res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-字符串相加"><a href="#2-字符串相加" class="headerlink" title="2. 字符串相加"></a>2. 字符串相加</h3><p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。</p>
<p>你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addStrings</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=num1.<span class="built_in">length</span>()<span class="number">-1</span>,j=num2.<span class="built_in">length</span>()<span class="number">-1</span>,<span class="built_in">flag</span>(<span class="number">0</span>);</span><br><span class="line">        string ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>||j&gt;=<span class="number">0</span>||flag&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=i&gt;=<span class="number">0</span>?num1[i]-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> y=j&gt;=<span class="number">0</span>?num2[j]-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> t=x+y+flag;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(t%<span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            flag=t/<span class="number">10</span>;</span><br><span class="line">            i--;j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-括号生成"><a href="#3-括号生成" class="headerlink" title="3. 括号生成"></a>3. 括号生成</h3><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="built_in">backTrack</span>(res,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backTrack</span><span class="params">(vector&lt;string&gt; &amp;res,string str,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;n || r&gt;n || r&gt;l) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(l == n &amp;&amp; r==n) res.<span class="built_in">push_back</span>(str);</span><br><span class="line">        <span class="built_in">backTrack</span>(res,str+<span class="string">&#x27;(&#x27;</span>,l+<span class="number">1</span>,r,n);</span><br><span class="line">        <span class="built_in">backTrack</span>(res,str+<span class="string">&#x27;)&#x27;</span>,l,r+<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-复原-IP-地址"><a href="#4-复原-IP-地址" class="headerlink" title="4. 复原 IP 地址"></a>4. 复原 IP 地址</h3><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p>
<p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#x31;&#57;&#x32;&#x2e;&#49;&#x36;&#x38;&#x40;&#49;&#46;&#x31;">&#x31;&#57;&#x32;&#x2e;&#49;&#x36;&#x38;&#x40;&#49;&#46;&#x31;</a>“ 是 无效 IP 地址。<br>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ret;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backTrace</span><span class="params">(string &amp;s,<span class="type">int</span> cnt,<span class="type">int</span> index,string&amp; str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">4</span> || index == s.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">4</span> &amp;&amp; index == s.<span class="built_in">size</span>())</span><br><span class="line">                ret.<span class="built_in">push_back</span>(str.<span class="built_in">substr</span>(<span class="number">0</span>,str.<span class="built_in">size</span>()<span class="number">-1</span>));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(index+i&gt;s.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[index]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;i!=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">3</span>&amp;&amp;s.<span class="built_in">substr</span>(index,i)&gt;<span class="string">&quot;255&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">            str+=s.<span class="built_in">substr</span>(index,i);</span><br><span class="line">            str.<span class="built_in">push_back</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            <span class="built_in">backTrace</span>(s,cnt+<span class="number">1</span>,index+i,str);</span><br><span class="line">            str=str.<span class="built_in">substr</span>(<span class="number">0</span>,str.<span class="built_in">size</span>()-i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">backTrace</span>(s,<span class="number">0</span>,<span class="number">0</span>,str);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-反转字符串中的单词"><a href="#5-反转字符串中的单词" class="headerlink" title="5. 反转字符串中的单词"></a>5. 反转字符串中的单词</h3><p>给你一个字符串 s ，请你反转字符串中 单词 的顺序。</p>
<p>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</p>
<p>返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(string &amp;s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        string temp;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">getline</span>(ss,temp,<span class="string">&#x27; &#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;&quot;</span> == temp) <span class="keyword">continue</span>;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ret=<span class="built_in">split</span>(s);</span><br><span class="line">        <span class="built_in">reverse</span>(ret.<span class="built_in">begin</span>(),ret.<span class="built_in">end</span>());</span><br><span class="line">        string res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ret.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=ret[i];</span><br><span class="line">            res+=<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res=res.<span class="built_in">substr</span>(<span class="number">0</span>,res.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-最小覆盖子串"><a href="#6-最小覆盖子串" class="headerlink" title="6.最小覆盖子串"></a>6.最小覆盖子串</h3><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
<p>双指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; &amp;hashmapS,unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; &amp;hashmapT)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; kv:hashmapT)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hashmapS.<span class="built_in">find</span>(kv.first)!=hashmapS.<span class="built_in">end</span>() &amp;&amp; hashmapS[kv.first] &gt;=kv.second)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string res=s;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; hashmapT,hashmapS;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hashmapT.<span class="built_in">find</span>(t[i]) == hashmapT.<span class="built_in">end</span>())</span><br><span class="line">                hashmapT[t[i]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hashmapT[t[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ptr1=<span class="number">0</span>,ptr2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ptr1&lt;=ptr2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(hashmapS,hashmapT) == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(hashmapS.<span class="built_in">find</span>(s[ptr2]) == hashmapS.<span class="built_in">end</span>()) hashmapS[s[ptr2]]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> hashmapS[s[ptr2]]++;</span><br><span class="line">                <span class="keyword">if</span>(ptr2&lt;s.<span class="built_in">size</span>() )ptr2++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(res.<span class="built_in">size</span>() &lt; s.<span class="built_in">substr</span>(ptr1,ptr2-ptr1+<span class="number">1</span>).<span class="built_in">size</span>())</span><br><span class="line">                    res=s.<span class="built_in">substr</span>(ptr1,ptr2-ptr1+<span class="number">1</span>);</span><br><span class="line">                hashmapS[s[ptr1]]--;</span><br><span class="line">                ptr1++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="7-比较版本号"><a href="#7-比较版本号" class="headerlink" title="7. 比较版本号"></a>7. 比较版本号</h3><p>给你两个版本号 <code>version1</code> 和 <code>version2</code> ，请你比较它们。</p>
<p>版本号由一个或多个修订号组成，各修订号由一个 ‘.’ 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。</p>
<p>比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(string&amp; str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line">        <span class="type">char</span> flag=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        string temp;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">getline</span>(ss,temp,flag))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!temp.<span class="built_in">empty</span>())</span><br><span class="line">                res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">compareVersion</span><span class="params">(string version1, string version2)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; vecVersion1 = <span class="built_in">split</span>(version1),vecVersion2 = <span class="built_in">split</span>(version2);</span><br><span class="line">        <span class="type">int</span> size=<span class="built_in">max</span>(vecVersion1.<span class="built_in">size</span>(),vecVersion2.<span class="built_in">size</span>());</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=i&lt;vecVersion1.<span class="built_in">size</span>()?<span class="built_in">atoi</span>(vecVersion1[i].<span class="built_in">c_str</span>()):<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> y=i&lt;vecVersion2.<span class="built_in">size</span>()?<span class="built_in">atoi</span>(vecVersion2[i].<span class="built_in">c_str</span>()):<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(x == y) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;y) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;y) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="8-字符串相乘"><a href="#8-字符串相乘" class="headerlink" title="8. 字符串相乘"></a>8. 字符串相乘</h3><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p>
<p>注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addStrings</span><span class="params">(string num1,string num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=num1.<span class="built_in">size</span>()<span class="number">-1</span>,j=num2.<span class="built_in">size</span>()<span class="number">-1</span>,flag=<span class="number">0</span>;</span><br><span class="line">        string res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> || j&gt;=<span class="number">0</span> || flag&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=i&gt;=<span class="number">0</span>?num1[i]-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> y=j&gt;=<span class="number">0</span>?num2[j]-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> temp=x+y+flag;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            flag=temp/<span class="number">10</span>;</span><br><span class="line">            i--;j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">multiply_s_c</span><span class="params">(string num1,<span class="type">char</span> num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> y=num2-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(num2 == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        string res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> i=num1.<span class="built_in">size</span>()<span class="number">-1</span>,flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> || flag &gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=i&gt;=<span class="number">0</span>?num1[i]-<span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> temp=x*y+flag;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            flag=temp/<span class="number">10</span>;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num1 == <span class="string">&quot;0&quot;</span> || num2 == <span class="string">&quot;0&quot;</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        string res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=num2.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            string temp=<span class="built_in">multiply_s_c</span>(num1,num2[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=num2.<span class="built_in">size</span>()<span class="number">-1</span>;j&gt;i;j--) temp.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            res=<span class="built_in">addStrings</span>(res,temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="9-最长公共前缀"><a href="#9-最长公共前缀" class="headerlink" title="9.  最长公共前缀"></a>9.  最长公共前缀</h3><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        string res=strs[0];</span><br><span class="line"></span><br><span class="line">        for(int i=1;i&lt;strs.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int j=0;</span><br><span class="line">            for(j=0;j&lt;min(strs[i].size(),res.size());j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(strs[i][j] == res[j])</span><br><span class="line">                    continue;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            res=res.substr(0,j);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="10-电话号码字母组合"><a href="#10-电话号码字母组合" class="headerlink" title="10. 电话号码字母组合"></a>10. 电话号码字母组合</h3><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ret;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backTrace</span><span class="params">(string&amp; digits,<span class="type">int</span> pos,string str,unordered_map&lt;<span class="type">char</span>,string&gt;&amp; hashmap)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == digits.<span class="built_in">size</span>()) </span><br><span class="line">        &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> temp=digits[pos];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;hashmap[temp].<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            str.<span class="built_in">push_back</span>(hashmap[temp][i]);</span><br><span class="line">            <span class="built_in">backTrace</span>(digits,pos+<span class="number">1</span>,str,hashmap);</span><br><span class="line">            str.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> ret;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,string&gt; hashmap;</span><br><span class="line">        hashmap[<span class="string">&#x27;2&#x27;</span>]=<span class="string">&quot;abc&quot;</span>; 	hashmap[<span class="string">&#x27;3&#x27;</span>]=<span class="string">&quot;def&quot;</span>; 	hashmap[<span class="string">&#x27;4&#x27;</span>]=<span class="string">&quot;ghi&quot;</span>;</span><br><span class="line">        hashmap[<span class="string">&#x27;5&#x27;</span>]=<span class="string">&quot;jkl&quot;</span>;		 hashmap[<span class="string">&#x27;6&#x27;</span>]=<span class="string">&quot;mno&quot;</span>; 	hashmap[<span class="string">&#x27;7&#x27;</span>]=<span class="string">&quot;pqrs&quot;</span>;</span><br><span class="line">        hashmap[<span class="string">&#x27;8&#x27;</span>]=<span class="string">&quot;tuv&quot;</span>;		hashmap[<span class="string">&#x27;9&#x27;</span>]=<span class="string">&quot;wxyz&quot;</span>;</span><br><span class="line">        <span class="built_in">backTrace</span>(digits,<span class="number">0</span>,<span class="string">&quot;&quot;</span>,hashmap);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="11-字母异位词"><a href="#11-字母异位词" class="headerlink" title="11. 字母异位词"></a>11. 字母异位词</h3><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ret;</span><br><span class="line">        unordered_map&lt;string,vector&lt;string&gt;&gt; hashmap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;strs.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            string temp=strs[i];</span><br><span class="line">            <span class="built_in">sort</span>(temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">            hashmap[temp].<span class="built_in">push_back</span>(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> kv:hashmap)</span><br><span class="line">        &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(kv.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="六、排序"><a href="#六、排序" class="headerlink" title="六、排序"></a>六、排序</h2><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-SgO11IMr-1663850245408)(<a target="_blank" rel="noopener" href="https://pic.leetcode-cn.com/1656597367-EDjKrb-%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png)]">https://pic.leetcode-cn.com/1656597367-EDjKrb-%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png)]</a></p>
<h3 id="1-手撕快排"><a href="#1-手撕快排" class="headerlink" title="1. 手撕快排"></a>1. 手撕快排</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> low = left,high = right;</span><br><span class="line">        <span class="comment">//swap(nums[left], nums[rand()%((right-left+1)+left)]);</span></span><br><span class="line">        <span class="type">int</span> base = nums[left];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; nums[high]&gt;=base) high--; <span class="keyword">if</span>(low&lt;high) nums[low] = nums[high];</span><br><span class="line">            <span class="keyword">while</span>(low&lt;high &amp;&amp; nums[low]&lt;=base) low++;   <span class="keyword">if</span>(low&lt;high) nums[high]=nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[low] = base;</span><br><span class="line">        <span class="built_in">quickSort</span>(nums,left,low<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quickSort</span>(nums,low+<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="built_in">quickSort</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-堆排序"><a href="#2-堆排序" class="headerlink" title="2. 堆排序"></a>2. 堆排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">maxHeapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> i, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; (i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span> &lt;= len;) &#123;</span><br><span class="line">            <span class="type">int</span> lson = (i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> rson = (i &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> large;</span><br><span class="line">            <span class="keyword">if</span> (lson &lt;= len &amp;&amp; nums[lson] &gt; nums[i]) &#123;</span><br><span class="line">                large = lson;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                large = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rson &lt;= len &amp;&amp; nums[rson] &gt; nums[large]) &#123;</span><br><span class="line">                large = rson;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (large != i) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[large]);</span><br><span class="line">                i = large;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildMaxHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = len / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="built_in">maxHeapify</span>(nums, i, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = (<span class="type">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">buildMaxHeap</span>(nums, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = len; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[<span class="number">0</span>]);</span><br><span class="line">            len -= <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">maxHeapify</span>(nums, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">heapSort</span>(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-归并"><a href="#3-归并" class="headerlink" title="3. 归并"></a>3. 归并</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, l, mid);</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="type">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[j]) &#123;</span><br><span class="line">                tmp[cnt++] = nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[cnt++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            tmp[cnt++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= r) &#123;</span><br><span class="line">            tmp[cnt++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r - l + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            nums[i + l] = tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        tmp.<span class="built_in">resize</span>((<span class="type">int</span>)nums.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">mergeSort</span>(nums, <span class="number">0</span>, (<span class="type">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-冒泡"><a href="#4-冒泡" class="headerlink" title="4. 冒泡"></a>4. 冒泡</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// bubbleSort</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;                 </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="literal">false</span>) <span class="keyword">break</span>; <span class="comment">//无交换，代表当前序列已经最优 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-选择排序"><a href="#5-选择排序" class="headerlink" title="5. 选择排序"></a>5. 选择排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// selectSort 选择排序</span></span><br><span class="line">        <span class="type">int</span> minIndex;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            minIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[minIndex]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[minIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-插入排序"><a href="#6-插入排序" class="headerlink" title="6. 插入排序"></a>6. 插入排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// insertSort 插入排序</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 第一个元素被认为已经被排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 两元素递增排序，则直接插入</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// nums[i] &lt; nums[i - 1]</span></span><br><span class="line">            <span class="comment">// 二分查找，时间复杂度logn</span></span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>, r = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">                <span class="comment">// r右侧元素均大于 nums[i]，即 r 及其左侧元素均小于等于nums[i]</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt; nums[mid]) r = mid - <span class="number">1</span>; </span><br><span class="line">                <span class="keyword">else</span> l = mid + <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> index = r + <span class="number">1</span>; <span class="comment">// 稳定排序，依次排列</span></span><br><span class="line">            <span class="comment">// 将当前 i 元素插入在 index 位置，index ~ i - 1 元素依次后移，时间复杂度n</span></span><br><span class="line">            <span class="type">int</span> tmp = nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i; k &gt;= index + <span class="number">1</span>; --k) &#123;</span><br><span class="line">                nums[k] = nums[k - <span class="number">1</span>]; <span class="comment">// 依次后移一位</span></span><br><span class="line">            &#125;</span><br><span class="line">            nums[index] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="7-希尔排序"><a href="#7-希尔排序" class="headerlink" title="7.希尔排序"></a>7.希尔排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums, <span class="type">int</span> gap, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j, tmp = nums[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; tmp &lt; nums[j]; j -= gap) &#123;</span><br><span class="line">            <span class="comment">// 依次后移</span></span><br><span class="line">            nums[j + gap] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j + gap] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 分组，最开始时，间隔 gap 为数组的一半</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> gap = n / <span class="number">2</span>; gap &gt;= <span class="number">1</span> ; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 对各个分组进行插入分组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="built_in">shellSort</span>(nums, gap, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="八、图"><a href="#八、图" class="headerlink" title="八、图"></a>八、图</h2><h3 id="1-迪杰斯特拉算法"><a href="#1-迪杰斯特拉算法" class="headerlink" title="1.迪杰斯特拉算法"></a>1.迪杰斯特拉算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求start节点到所有节点的最短路径 编号：0~n-1</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Dijkstra</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; Graph, <span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(Graph.size())</span></span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(Graph.size(),INT_MAX)</span></span>;</span><br><span class="line">	dis[start] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Graph.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> minn = INT_MAX, temp = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; Graph.<span class="built_in">size</span>(); j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!vis[j] &amp;&amp; dis[j] &lt; minn)</span><br><span class="line">			&#123;</span><br><span class="line">				minn = dis[j];</span><br><span class="line">				temp = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (temp == <span class="number">-1</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">		vis[temp] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; Graph.<span class="built_in">size</span>(); k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!vis[k] &amp;&amp; Graph[temp][k] != <span class="number">0</span>)</span><br><span class="line">				dis[k] = <span class="built_in">min</span>(dis[k], Graph[temp][k] + dis[temp]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-图中找单词"><a href="#2-图中找单词" class="headerlink" title="2.图中找单词"></a>2.图中找单词</h3><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p><strong>思路：</strong></p>
<p>设函数 check(i,j,k) 表示判断以网格的 (i, j)位置出发，能否搜索到单词word[k..]，其中word[k..]表示字符串word 从第 k 个字符开始的后缀子串。如果能搜索到，则返回true，反之返回false。</p>
<p>函数check(i,j,k)  的执行步骤如下：</p>
<p>如果 board[i，j]≠s[k], 当前字符不匹配，直接返回false。</p>
<p>如果当前已经访问到字符串的末尾，且对应字符依然匹配，此时直接返回true。</p>
<p>否则，遍历当前位置的所有相邻位置。如果从某个相邻位置出发，能够搜索到子word[k+1..]，则返回true，否则返回false。</p>
<h2 id="九、其他"><a href="#九、其他" class="headerlink" title="九、其他"></a>九、其他</h2><h3 id="1-LRU-缓存"><a href="#1-LRU-缓存" class="headerlink" title="1. LRU 缓存"></a>1. LRU 缓存</h3><p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：<br>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。<br>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p>
<p><strong>哈希表 + 双向链表</strong></p>
<p>RU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。</p>
<p>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</p>
<p>哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。</p>
<p>对于 <strong>get</strong> 操作，首先判断 key 是否存在：</p>
<p>​		如果 <strong>key</strong> 不存在，则返回 -1；</p>
<p>​		如果 <strong>key</strong> 存在，则 key 对应的节点是最近被使用的节点。</p>
<p>​					通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。</p>
<p>对于 <strong>put</strong> 操作，首先判断 key 是否存在：</p>
<p>​		如果 <strong>key</strong> 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。</p>
<p>​					然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；</p>
<p>​		如果 <strong>key</strong> 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DLinkNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key,value;</span><br><span class="line">    DLinkNode *pre,*next;</span><br><span class="line">    <span class="built_in">DLinkNode</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">DLinkNode</span>(<span class="type">int</span> _key,<span class="type">int</span> _value):<span class="built_in">key</span>(_key),<span class="built_in">value</span>(_value)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size,capacity;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, DLinkNode*&gt; hashmap;</span><br><span class="line">    DLinkNode *head,*tail;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveToHead</span><span class="params">(DLinkNode *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node-&gt;pre-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;pre = node-&gt;pre;</span><br><span class="line">        <span class="built_in">insertToHead</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertToHead</span><span class="params">(DLinkNode *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node-&gt;next=head-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;pre = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">        node-&gt;pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteTail</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DLinkNode *temp = tail-&gt;pre;</span><br><span class="line">        temp-&gt;pre-&gt;next=tail;</span><br><span class="line">        tail-&gt;pre = temp-&gt;pre;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> _capacity):<span class="built_in">capacity</span>(_capacity),<span class="built_in">size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">DLinkNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">DLinkNode</span>();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;pre=head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hashmap.<span class="built_in">find</span>(key) == hashmap.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">moveToHead</span>(hashmap[key]);</span><br><span class="line">        <span class="keyword">return</span> hashmap[key]-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hashmap.<span class="built_in">find</span>(key) != hashmap.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 存在</span></span><br><span class="line">            hashmap[key]-&gt;value = value;</span><br><span class="line">            <span class="built_in">moveToHead</span>(hashmap[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 不存在</span></span><br><span class="line">            DLinkNode *node = <span class="keyword">new</span> <span class="built_in">DLinkNode</span>(key,value);</span><br><span class="line">            hashmap[key] = node;</span><br><span class="line">            <span class="built_in">insertToHead</span>(node);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">if</span>(size &gt; capacity)</span><br><span class="line">            &#123;</span><br><span class="line">                hashmap.<span class="built_in">erase</span>(tail-&gt;pre-&gt;key);</span><br><span class="line">                <span class="built_in">deleteTail</span>();</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-全排列"><a href="#2-全排列" class="headerlink" title="2. 全排列"></a>2. 全排列</h3><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backTrack</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res,vector&lt;<span class="type">int</span>&gt;&amp; out,<span class="type">int</span> first,<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(first == len)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(out);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=first;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(out[i],out[first]);</span><br><span class="line">            <span class="built_in">backTrack</span>(res,out,first+<span class="number">1</span>,len);</span><br><span class="line">            <span class="built_in">swap</span>(out[i],out[first]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="built_in">backTrack</span>(ret,nums,<span class="number">0</span>,nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-x的平方根"><a href="#3-x的平方根" class="headerlink" title="3. x的平方根"></a>3. x的平方根</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans = <span class="built_in">exp</span>(<span class="number">0.5</span> * <span class="built_in">log</span>(x));</span><br><span class="line">        <span class="comment">// return ((long long)(ans + 1) * (ans + 1) &lt;= x ? ans + 1 : ans);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-360笔试老张修路"><a href="#4-360笔试老张修路" class="headerlink" title="4. 360笔试老张修路"></a>4. 360笔试老张修路</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 老张修路</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; father;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> father[x] == x ? x : father[x] = <span class="built_in">find</span>(father[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a[<span class="number">2</span>] &lt; b[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n, m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	father  = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+ <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) father[i] = i;</span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">edges</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">			cin &gt;&gt; edges[j][i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), cmp);</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="type">int</span> f1 = <span class="built_in">find</span>(edges[i][<span class="number">0</span>]), f2 = <span class="built_in">find</span>(edges[i][<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">if</span> (f1 == f2)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		ans += edges[i][<span class="number">2</span>];</span><br><span class="line">		<span class="type">int</span> ff = <span class="built_in">min</span>(f1, f2);</span><br><span class="line">		father[f1] = father[f2] = ff;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-360笔试魔塔闯关"><a href="#5-360笔试魔塔闯关" class="headerlink" title="5. 360笔试魔塔闯关"></a>5. 360笔试魔塔闯关</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">	<span class="keyword">while</span> (n-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="type">int</span> a, b;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		<span class="keyword">if</span> (b == <span class="number">0</span>) </span><br><span class="line">			res += a;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			nums.<span class="built_in">push_back</span>(a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		res += <span class="built_in">max</span>(nums[i], res);</span><br><span class="line">	cout &lt;&lt; res;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-手写vector"><a href="#6-手写vector" class="headerlink" title="6. 手写vector"></a>6. 手写vector</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> VECTOR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VECTOR_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Object&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> this_capcity;</span><br><span class="line">	<span class="type">int</span> this_size;</span><br><span class="line">	Object* object;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">vector</span>() :<span class="built_in">this_capcity</span>(<span class="number">5</span>), <span class="built_in">this_size</span>(<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		object = <span class="keyword">new</span> Object[<span class="number">5</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">(<span class="type">int</span> thisCapcity)</span>:this_capcity(thisCapcity), this_size(<span class="number">0</span>)</span></span><br><span class="line"><span class="function">	&#123;</span></span><br><span class="line">		object = <span class="keyword">new</span> Object[thisCapcity];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">vector</span>(<span class="type">const</span> vector&amp; v)</span><br><span class="line">	&#123;</span><br><span class="line">		*<span class="keyword">this</span> = v;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">vector</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[] object;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">int</span> newSize)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (this_size &lt; newSize)</span><br><span class="line">		&#123;</span><br><span class="line">			this_size = newSize;</span><br><span class="line">			<span class="built_in">reserve</span>(newSize * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">int</span> newCapcity)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (this_capcity &lt; newCapcity)</span><br><span class="line">		&#123;</span><br><span class="line">			Object* temp = <span class="keyword">new</span> Object[newCapcity];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; this_size;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				temp[i] = object[i];</span><br><span class="line">			&#125;</span><br><span class="line">			this_capcity = newCapcity;</span><br><span class="line">			object = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> this_size;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">capcity</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> this_capcity;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(Object val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (this_size == this_capcity)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">reserve</span>(this_capcity * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		object[this_size] = val;</span><br><span class="line">		this_size++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Object <span class="title">front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (this_size) <span class="keyword">return</span> object[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">throw</span> <span class="string">&quot;OutOfBounds Exception!&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (this_size) this_size--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(index&gt;this_size) <span class="keyword">throw</span> <span class="string">&quot;OutOfBounds Exception!&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = index + <span class="number">1</span>;i &lt; this_size;i++) object[i - <span class="number">1</span>] = object[i];</span><br><span class="line">		this_size--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Object <span class="title">back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (this_size) <span class="keyword">return</span> object[this_size<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">throw</span> <span class="string">&quot;OutOfBounds Exception!&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Object <span class="keyword">operator</span> [](<span class="type">int</span> index)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (index &lt; this_size) <span class="keyword">return</span> object[index];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">&quot;OutOfBounds Exception!&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	vector&amp; <span class="keyword">operator</span> = (<span class="type">const</span> vector&amp; v)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> != v)</span><br><span class="line">		&#123;</span><br><span class="line">			this_size = v.this_size;</span><br><span class="line">			this_capcity = v.this_capcity;</span><br><span class="line">			object = <span class="keyword">new</span> Object[this_capcity];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; this_size;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				object[i] = v[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">		cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.<span class="built_in">capcity</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	v.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line">	cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v.<span class="built_in">capcity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v.front()&quot;</span> &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; v.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;v.back()&quot;</span> &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; v.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	v.<span class="built_in">pop_back</span>();</span><br><span class="line">	v.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; v.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> VECTOR_H</span></span><br></pre></td></tr></table></figure>

<h3 id="7-手写string"><a href="#7-手写string" class="headerlink" title="7.手写string"></a>7.手写string</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYSTRING_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYSTRING_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myString</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; out, myString &amp;) ;</span><br><span class="line">    <span class="keyword">friend</span> istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp; in, myString &amp;) ;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">myString</span>();  <span class="comment">// 默认构造</span></span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">myString</span>();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="built_in">myString</span>(<span class="type">const</span> <span class="type">char</span> *); <span class="comment">// 由字符串构造</span></span><br><span class="line">        <span class="built_in">myString</span>(<span class="type">const</span> myString &amp;); <span class="comment">// 拷贝构造函数</span></span><br><span class="line"> </span><br><span class="line">        myString &amp; <span class="keyword">operator</span>=(<span class="type">const</span> myString &amp;);   <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">        myString &amp; <span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span> *);   <span class="comment">// 由字符串构造</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="built_in">myString</span>(myString &amp;&amp;) <span class="keyword">noexcept</span>;  <span class="comment">// 移动构造函数</span></span><br><span class="line">        myString &amp; <span class="keyword">operator</span>=(myString &amp;&amp;) <span class="keyword">noexcept</span>;  <span class="comment">// 移动赋值运算符</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getLength</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getCapacity</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">getStr</span><span class="params">()</span> <span class="type">const</span></span>;  <span class="comment">// 获取 C 字符串</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="type">char</span> &amp; <span class="keyword">operator</span>[](<span class="type">int</span>);  <span class="comment">// 获取 第 i 位字符</span></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> myString&amp; str); <span class="comment">// 判断两个字符串是否相等</span></span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">char</span> c)</span></span>;  <span class="comment">// 追加一个字符</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * s)</span></span>; <span class="comment">// 追加一个字符串</span></span><br><span class="line"> </span><br><span class="line">        myString  <span class="keyword">operator</span>+(<span class="type">const</span> <span class="type">char</span> * s);  <span class="comment">// 拼接字符串</span></span><br><span class="line">        myString  <span class="keyword">operator</span>+(<span class="type">const</span> myString &amp; s2);  <span class="comment">// 拼接字符串</span></span><br><span class="line">        myString &amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span> * s); <span class="comment">// 追加字符串</span></span><br><span class="line">        myString &amp; <span class="keyword">operator</span>+=(<span class="type">const</span> myString &amp; s); <span class="comment">// 追加字符串</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">char</span> * str;</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="type">int</span> capacity;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYSTRING_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyString.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line">myString::<span class="built_in">myString</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;capacity = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;str = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="keyword">this</span>-&gt;capacity);<span class="comment">// 默认分配一个长度为15的字符数组,初始化为空串</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;str[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">myString::~<span class="built_in">myString</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//dtor</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;str != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>-&gt;str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">myString::<span class="built_in">myString</span>(<span class="type">const</span> <span class="type">char</span> * s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="type">int</span> sz = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">this</span>-&gt;length = sz;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = sz+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;str = (<span class="type">char</span> * ) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="keyword">this</span>-&gt;capacity);  <span class="comment">// 按字符串大小复制</span></span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;str,s);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;str = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="keyword">this</span>-&gt;capacity);<span class="comment">// 默认分配一个长度为15的字符数组,初始化为空串</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;str[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">myString::<span class="built_in">myString</span>(<span class="type">const</span> myString &amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;length = s.<span class="built_in">getLength</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;capacity = s.<span class="built_in">getCapacity</span>();</span><br><span class="line">    <span class="keyword">this</span>-&gt;str = (<span class="type">char</span> * ) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="keyword">this</span>-&gt;capacity);  <span class="comment">// 按字符串大小复制</span></span><br><span class="line">    <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;str,s.<span class="built_in">getStr</span>());</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 移动构造函数</span></span><br><span class="line">myString::<span class="built_in">myString</span>(myString &amp;&amp; s) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;length = s.length;</span><br><span class="line">    <span class="keyword">this</span>-&gt;capacity = s.capacity;</span><br><span class="line">    <span class="keyword">this</span>-&gt;str = s.str;</span><br><span class="line"> </span><br><span class="line">    s.length = <span class="number">0</span>;</span><br><span class="line">    s.capacity = <span class="number">0</span>;</span><br><span class="line">    s.str = <span class="literal">nullptr</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">myString &amp; myString::<span class="keyword">operator</span>=(myString &amp;&amp; s) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp; s) &#123;   <span class="comment">// 是否自赋值</span></span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>-&gt;str);</span><br><span class="line">        <span class="keyword">this</span>-&gt;length = s.length;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = s.capacity;</span><br><span class="line">        <span class="keyword">this</span>-&gt;str = s.str;</span><br><span class="line">        s.length = <span class="number">0</span>;</span><br><span class="line">        s.capacity = <span class="number">0</span>;</span><br><span class="line">        s.str = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">myString &amp; myString::<span class="keyword">operator</span>=(<span class="type">const</span> myString &amp; s) &#123;  <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;s) &#123;  <span class="comment">// 检查自赋值</span></span><br><span class="line">        <span class="type">int</span> sz = s.<span class="built_in">getLength</span>();</span><br><span class="line">        <span class="keyword">if</span>(sz &lt; <span class="keyword">this</span>-&gt;capacity) &#123; <span class="comment">// 如果原字符串容量够，那么直接拷贝</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;length = sz;</span><br><span class="line">            <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;str,s.<span class="built_in">getStr</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 容量不够，释放掉原有内存，重新申请</span></span><br><span class="line">            <span class="built_in">free</span>(<span class="keyword">this</span>-&gt;str);  <span class="comment">// 释放掉原有的字符串</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;length = s.<span class="built_in">getLength</span>();</span><br><span class="line">            <span class="keyword">this</span>-&gt;capacity = s.<span class="built_in">getCapacity</span>();</span><br><span class="line">            <span class="keyword">this</span>-&gt;str = (<span class="type">char</span> * ) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="keyword">this</span>-&gt;capacity);  <span class="comment">// 按字符串大小复制</span></span><br><span class="line">            <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;str,s.<span class="built_in">getStr</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">myString &amp; myString::<span class="keyword">operator</span>=(<span class="type">const</span> <span class="type">char</span> * s) &#123;  <span class="comment">// 字符串构造</span></span><br><span class="line">    <span class="keyword">if</span>(s != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="type">int</span> sz = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">if</span>(sz &lt; <span class="keyword">this</span>-&gt;capacity) &#123;  <span class="comment">// 如果原字符串容量够，那么直接拷贝</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;length = sz;</span><br><span class="line">            <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;str,s);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 容量不够，释放掉原有内存，重新申请</span></span><br><span class="line">            <span class="built_in">free</span>(<span class="keyword">this</span>-&gt;str);</span><br><span class="line">            <span class="keyword">this</span>-&gt;length = sz;</span><br><span class="line">            <span class="keyword">this</span>-&gt;capacity = sz+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;str = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="keyword">this</span>-&gt;capacity);</span><br><span class="line">            <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;str,s);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;str = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="keyword">this</span>-&gt;capacity);<span class="comment">// 默认分配一个长度为15的字符数组,初始化为空串</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;str[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myString::getLength</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;length;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myString::getCapacity</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;capacity;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">myString::getStr</span><span class="params">()</span> <span class="type">const</span>  <span class="comment">// 不允许修改 str</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;str;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> &amp; myString::<span class="keyword">operator</span>[](<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt; <span class="keyword">this</span>-&gt;length) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;index out of range!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;str[<span class="keyword">this</span>-&gt;length];     <span class="comment">// 返回最后一个字符，也就是&#x27;\0&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;str[i];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">bool</span> myString::<span class="keyword">operator</span>==(<span class="type">const</span> myString &amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;length != s.<span class="built_in">getLength</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(<span class="keyword">this</span>-&gt;str,s.<span class="built_in">getStr</span>()) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myString::append</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sz = <span class="number">1</span> + <span class="keyword">this</span>-&gt;length;</span><br><span class="line">    <span class="keyword">if</span>(sz  &gt;= <span class="keyword">this</span>-&gt;capacity) &#123;  <span class="comment">// 追加后字符大于字符数组长度</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">this</span>-&gt;capacity &lt;= (<span class="built_in">sizeof</span>(<span class="type">char</span>) * sz)) <span class="keyword">this</span>-&gt;capacity = (<span class="keyword">this</span>-&gt;capacity + <span class="keyword">this</span>-&gt;capacity &gt;&gt; <span class="number">1</span>);   <span class="comment">// 容量变为1.5，直到大于拼接字符串的长度</span></span><br><span class="line">        <span class="type">char</span> * newStr = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">this</span>-&gt;capacity);</span><br><span class="line">        <span class="built_in">strcpy</span>(newStr,<span class="keyword">this</span>-&gt;str);</span><br><span class="line">        newStr[sz] = c;</span><br><span class="line">        newStr[sz+<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>-&gt;str);</span><br><span class="line">        <span class="keyword">this</span>-&gt;str = newStr;</span><br><span class="line">        <span class="keyword">this</span>-&gt;length = sz;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;str[sz] = c;</span><br><span class="line">        <span class="keyword">this</span>-&gt;str[sz+<span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;length = sz;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myString::append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sz = <span class="built_in">strlen</span>(s) + <span class="keyword">this</span>-&gt;length;</span><br><span class="line">    <span class="keyword">if</span>(sz  &gt;= <span class="keyword">this</span>-&gt;capacity) &#123;  <span class="comment">// 追加后字符串大于字符数组长度</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">this</span>-&gt;capacity &lt;= (<span class="built_in">sizeof</span>(<span class="type">char</span>) * sz)) <span class="keyword">this</span>-&gt;capacity = (<span class="keyword">this</span>-&gt;capacity + <span class="keyword">this</span>-&gt;capacity / <span class="number">2</span>);   <span class="comment">// 容量变为1.5，直到大于拼接字符串的长度</span></span><br><span class="line">        <span class="type">char</span> * newStr = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">this</span>-&gt;capacity);</span><br><span class="line">        <span class="built_in">strcpy</span>(newStr,<span class="keyword">this</span>-&gt;str);</span><br><span class="line">        newStr = <span class="built_in">strcat</span>(newStr,s);</span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>-&gt;str);</span><br><span class="line">        <span class="keyword">this</span>-&gt;str = newStr;</span><br><span class="line">        <span class="keyword">this</span>-&gt;length = sz;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;str = <span class="built_in">strcat</span>(<span class="keyword">this</span>-&gt;str, s);</span><br><span class="line">        <span class="keyword">this</span>-&gt;length = sz;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">myString myString::<span class="keyword">operator</span>+(<span class="type">const</span> <span class="type">char</span> * s)  <span class="comment">// 拼接字符串</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">myString <span class="title">res</span><span class="params">(<span class="keyword">this</span>-&gt;str)</span></span>;</span><br><span class="line">    res += s;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">myString myString::<span class="keyword">operator</span>+(<span class="type">const</span> myString &amp; s)  <span class="comment">// 拼接字符串</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">append</span>(s.<span class="built_in">getStr</span>());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">myString &amp; myString::<span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span> * s) <span class="comment">// 追加字符串</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">append</span>(s);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">myString &amp; myString::<span class="keyword">operator</span>+=(<span class="type">const</span> myString &amp; s) <span class="comment">// 追加字符串</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">append</span>(s.<span class="built_in">getStr</span>());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; out, myString &amp; myStr)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; (myStr.str) ;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp; in, myString &amp; myStr)</span><br><span class="line">&#123;</span><br><span class="line">    in &gt;&gt; myStr.str;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="web服务器项目常见面试题目"><a href="#web服务器项目常见面试题目" class="headerlink" title="web服务器项目常见面试题目"></a>web服务器项目常见面试题目</h1><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><h3 id="1、为什么要做这样一个项目？"><a href="#1、为什么要做这样一个项目？" class="headerlink" title="1、为什么要做这样一个项目？"></a>1、为什么要做这样一个项目？</h3><p>在学习C++语言的时候，发现需要做一个项目来巩固一下，网上有推荐这个项目，然后就自己尝试做了一下。这个项目综合性比较强，从中既能学习Linux环境下的一些系统调用，也能熟悉网络编程。</p>
<h3 id="2、介绍下你的项目"><a href="#2、介绍下你的项目" class="headerlink" title="2、介绍下你的项目"></a>2、介绍下你的项目</h3><p>服务器基本框架</p>
<p><img src="https://img-blog.csdnimg.cn/7d0a4d878d5444e1abce99530f018015.png" alt="img"></p>
<p>此项目是基于Linux的轻量级多线程Web服务器，应用层实现了一个简单的HTTP服务器，利用多路IO复用，可以同时监听多个请求，使用线程池处理请求，使用模拟proactor模式，主线程负责监听，监听有事件之后，从socket中循环读取数据，然后将读取到的数据封装成一个请求对象放入队列。睡眠在请求队列上的工作线程被唤醒进行处理，使用状态机解析HTTP请求报文，实现同步&#x2F;异步日志系统，记录服务器运行状态，并对系统进行了压力测试。</p>
<h3 id="3、你的项目的技术难点是什么？"><a href="#3、你的项目的技术难点是什么？" class="headerlink" title="3、你的项目的技术难点是什么？"></a>3、你的项目的技术难点是什么？</h3><p>​	1、如何提高服务器的并发能力</p>
<p>​	2、由于涉及到I&#x2F;O操作，当单条日志比较大的时候，同步模式会阻塞整个处理流程</p>
<p>​	3、多线程并发的情况下，保证线程的同步</p>
<h3 id="4、你是如何克服这个技术难点的？"><a href="#4、你是如何克服这个技术难点的？" class="headerlink" title="4、你是如何克服这个技术难点的？"></a>4、你是如何克服这个技术难点的？</h3><h3 id="5、你做这个项目的收获是什么？"><a href="#5、你做这个项目的收获是什么？" class="headerlink" title="5、你做这个项目的收获是什么？"></a>5、你做这个项目的收获是什么？</h3><h3 id="6、为什么使用这个技术／组件？"><a href="#6、为什么使用这个技术／组件？" class="headerlink" title="6、为什么使用这个技术／组件？"></a>6、为什么使用这个技术／组件？</h3><h3 id="7、如何解决项目中的BUG"><a href="#7、如何解决项目中的BUG" class="headerlink" title="7、如何解决项目中的BUG"></a>7、如何解决项目中的BUG</h3><p>（1）运行代码，发现错误，找到报错的位置。</p>
<p>（2）如果注释后运行正常了，那么就是注释掉的部分有误了</p>
<p>（3）若不是，则从main 函数里边调用的开始下手，查看定义，跳转到定义的功能，这很大程度上能让我们快速的找到bug。</p>
<h3 id="8、为什么所有人都是这个服务器项目"><a href="#8、为什么所有人都是这个服务器项目" class="headerlink" title="8、为什么所有人都是这个服务器项目"></a>8、为什么所有人都是这个服务器项目</h3><p>自己接触到C++最好的练手项目就是webserver，也不知道其他人 都做这个。 </p>
<h3 id="9、项目的异常处理有哪些"><a href="#9、项目的异常处理有哪些" class="headerlink" title="9、项目的异常处理有哪些"></a>9、项目的异常处理有哪些</h3><p> （1）登录异常</p>
<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 用户不存在：根据账号在数据库查，如果查不到就是</span><br><span class="line">* 用户名或密码错误：数据库查询的用户密码和http请求用户输入的密码比对，如果不一致</span><br><span class="line">* 登录成功</span><br></pre></td></tr></table></figure>

<p>try-catch语句</p>
<p>程序先执行 try 中的代码<br>如果 try 中的代码出现异常, 就会结束 try 中的代码, 看和 catch 中的异常类型是否匹配.<br>如果找到匹配的异常类型, 就会执行 catch 中的代码<br>如果没有找到匹配的异常类型, 就会将异常向上传递到上层调用者.<br>无论是否找到匹配的异常类型, finally 中的代码都会被执行到(在该方法结束之前执行).<br>如果上层调用者也没有处理的了异常, 就继续向上传递<br>一直到 main 方法也没有合适的代码处理异常, 就会交给 JVM 来进行处理, 此时程序就会异常终止</p>
<h3 id="10、项目中用到了什么协议"><a href="#10、项目中用到了什么协议" class="headerlink" title="10、项目中用到了什么协议"></a>10、项目中用到了什么协议</h3><p> HTTP、ＴＣＰ、ＤＮＳ</p>
<h2 id="线程池相关"><a href="#线程池相关" class="headerlink" title="线程池相关"></a>线程池相关</h2><h3 id="1、为什么使用线程池"><a href="#1、为什么使用线程池" class="headerlink" title="1、为什么使用线程池"></a>1、为什么使用线程池</h3><p>每个请求对应一个线程方法的不足之一是：为每个请求创建一个新线程的开销很大；为每个请求创建新线程的服务器在创建和销毁线程上花费的时间和消耗的系统资源要比花在处理实际的用户请求的时间和资源更多。</p>
<p>线程池是为了避免创建和销毁线程所产生的开销，避免活动的线程消耗的系统资源；</p>
<p>提高响应速度，任务到达时，无需等待线程即可立即执行；</p>
<p>提高线程的可管理性：线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。</p>
<h3 id="2、怎么创建线程池（线程池运行逻辑）"><a href="#2、怎么创建线程池（线程池运行逻辑）" class="headerlink" title="2、怎么创建线程池（线程池运行逻辑）"></a>2、怎么创建线程池（线程池运行逻辑）</h3><p> 该项目使用线程池（半同步半反应堆模式）并发处理用户请求，主线程负责读写，工作线程（线程池中的线程）负责处理逻辑（HTTP请求报文的解析等）。</p>
<p>具体的：主线程为异步线程，负责监听文件描述符，接收socket新连接，若当前监听的socket发生了读写事件，然后将任务插入到请求队列。工作线程从请求队列中取出任务，完成读写数据的处理。</p>
<p>线程池是空间换时间,浪费服务器的硬件资源,换取运行效率.</p>
<h3 id="3、线程的同步机制有哪些？"><a href="#3、线程的同步机制有哪些？" class="headerlink" title="3、线程的同步机制有哪些？"></a>3、线程的同步机制有哪些？</h3><p>（1）同步I&#x2F;O</p>
<p>同步I&#x2F;O指内核向应用程序通知的是就绪事件，比如只通知有客户端连接，要求用户代码自行执行I&#x2F;O操作</p>
<p>a ) 阻塞IO:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作</p>
<p>b ) 非阻塞IO:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I&#x2F;O执行系统调用总是立即返回，不管时间是否已经发生，若时间没有发生，则返回-1，此时可以根据errno区分这两种情况，对于accept，recv和send，事件未发生时，errno通常被设置成eagain</p>
<p>c ) 信号驱动IO:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。</p>
<p>d ) IO复用:linux用select&#x2F;poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数</p>
<p>（2）异步I&#x2F;O</p>
<p>异步I&#x2F;O是指内核向应用程序通知的是完成事件，比如读取客户端的数据后才通知应用程序，由内核完成I&#x2F;O操作</p>
<p> linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</p>
<h3 id="4、线程池中的工作线程是一直等待吗？"><a href="#4、线程池中的工作线程是一直等待吗？" class="headerlink" title="4、线程池中的工作线程是一直等待吗？"></a>4、线程池中的工作线程是一直等待吗？</h3><p>在run函数中，我们为了能够处理高并发的问题，将线程池中的工作线程都设置为阻塞等待在请求队列是否不为空的条件上，因此项目中线程池中的工作线程是处于一直阻塞等待的模式下的。 </p>
<h3 id="5、你的线程池工作线程处理完一个任务后的状态是什么？"><a href="#5、你的线程池工作线程处理完一个任务后的状态是什么？" class="headerlink" title="5、你的线程池工作线程处理完一个任务后的状态是什么？"></a>5、你的线程池工作线程处理完一个任务后的状态是什么？</h3><p>（1） 当处理完任务后如果请求队列为空时，则这个线程重新回到阻塞等待的状态</p>
<p>（2） 当处理完任务后如果请求队列不为空时，那么这个线程将处于与其他线程竞争资源的状态，谁获得锁谁就获得了处理事件的资格。</p>
<h3 id="6、如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？"><a href="#6、如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？" class="headerlink" title="6、如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？"></a>6、如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？</h3><p>本项目是通过对子线程循环调用来解决高并发的问题的。</p>
<p>首先在创建线程的同时就调用了pthread_detach将线程进行分离，不用单独对工作线程进行回收，资源自动回收。</p>
<p>我们通过子线程的run调用函数进行while循环，让每一个线程池中的线程永远都不会停止，访问请求被封装到请求队列(list)中，如果没有任务线程就一直阻塞等待，有任务线程就抢占式进行处理，直到请求队列为空，表示任务全部处理完成。</p>
<h3 id="7、如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢"><a href="#7、如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢" class="headerlink" title="7、如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢?"></a>7、如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢?</h3><p>会，因为线程池内线程的数量时有限的，如果客户请求占用线程时间过久的话会影响到处理请求的效率，当请求处理过慢时会造成后续接受的请求只能在请求队列中等待被处理，从而影响接下来的客户请求。</p>
<p>应对策略：</p>
<p>我们可以为线程处理请求对象设置处理超时时间, 超过时间先发送信号告知线程处理超时，然后设定一个时间间隔再次检测，若此时这个请求还占用线程则直接将其断开连接。</p>
<h3 id="8、什么是虚假唤醒？"><a href="#8、什么是虚假唤醒？" class="headerlink" title="8、什么是虚假唤醒？"></a>8、什么是虚假唤醒？</h3><p>举个例子，我们现在有一个生产者-消费者队列和三个线程。</p>
<p>1） 1号线程从队列中获取了一个元素，此时队列变为空。</p>
<p>2） 2号线程也想从队列中获取一个元素，但此时队列为空，2号线程便只能进入阻塞(cond.wait())，等待队列非空。</p>
<p>3） 这时，3号线程将一个元素入队，并调用cond.notify()唤醒条件变量。</p>
<p>4） 处于等待状态的2号线程接收到3号线程的唤醒信号，便准备解除阻塞状态，执行接下来的任务(获取队列中的元素)。</p>
<p>5） 然而可能出现这样的情况：当2号线程准备获得队列的锁，去获取队列中的元素时，此时1号线程刚好执行完之前的元素操作，返回再去请求队列中的元素，1号线程便获得队列的锁，检查到队列非空，就获取到了3号线程刚刚入队的元素，然后释放队列锁。</p>
<p>6） 等到2号线程获得队列锁，判断发现队列仍为空，1号线程“偷走了”这个元素，所以对于2号线程而言，这次唤醒就是“虚假”的，它需要再次等待队列非空。</p>
<h3 id="9、介绍一下几种典型的锁？"><a href="#9、介绍一下几种典型的锁？" class="headerlink" title="9、介绍一下几种典型的锁？"></a>9、介绍一下几种典型的锁？</h3><p>线程池的实现还需要依靠锁机制以及信号量机制来实现线程同步，保证操作的原子性 </p>
<p>（1）读写锁</p>
<p>多个读者可以同时进行读<br>写者必须互斥（只允许一个写者写，也不能读者写者同时进行）<br>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</p>
<p>（2）互斥锁</p>
<p>一次只能一个线程拥有互斥锁，其他线程只有等待</p>
<p>互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。<br>（3）条件变量</p>
<p>互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说互斥锁是线程间互斥的机制，条件变量则是同步机制。</p>
<p>（4）自旋锁</p>
<p>如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。</p>
<h3 id="10、如何销毁线程"><a href="#10、如何销毁线程" class="headerlink" title="10、如何销毁线程"></a>10、如何销毁线程</h3><p>1、通过判断标志位，主动退出<br>2、通过Thread类中成员方法interrupt()，主动退出<br>3、通过Thread类中成员方法stop()，强行退出</p>
<h3 id="11、detach和join有什么区别"><a href="#11、detach和join有什么区别" class="headerlink" title="11、detach和join有什么区别"></a>11、detach和join有什么区别</h3><p>（1）当调用join()，主线程等待子线程执行完之后，主线程才可以继续执行，此时主线程会释放掉执行完后的子线程资源。主线程等待子线程执行完，可能会造成性能损失。</p>
<p>（2）当调用detach()，主线程与子线程分离，他们成为了两个独立的线程遵循cpu的时间片调度分配策略。子线程执行完成后会自己释放掉资源。分离后的线程，主线程将对它没有控制权。</p>
<p>当你确定程序没有使用共享变量或引用之类的话，可以使用detch函数，分离线程。</p>
<h3 id="12、每个线程占多大的内存"><a href="#12、每个线程占多大的内存" class="headerlink" title="12、每个线程占多大的内存"></a>12、每个线程占多大的内存</h3><p> 32位系统，分配4G的虚拟内存给进程，每个线程约占10M的内存</p>
<h3 id="13、线程池中有多少个线程，线程池数量如何设定"><a href="#13、线程池中有多少个线程，线程池数量如何设定" class="headerlink" title="13、线程池中有多少个线程，线程池数量如何设定"></a>13、线程池中有多少个线程，线程池数量如何设定</h3><p>默认8个</p>
<p>调整线程池中的线程数量的最主要的目的是为了充分并合理地使用 CPU 和内存等资源，从而最大限度地提高程序的性能。</p>
<p>Ncpu 表示 CPU的数量。</p>
<p>如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 Ncpu+1。</p>
<p>如果是IO密集型任务，参考值可以设置为 2 * Ncpu。因为线程间竞争的不是CPU的计算资源而是IO，IO的处理一般较慢，多于cores数的线程将为CPU争取更多的任务，不至在线程处理IO的过程造成CPU空闲导致资源浪费。</p>
<p>最佳线程数量 &#x3D; （（线程等待时间+线程CPU时间）／ 线程CPU时间）* CPU个数。</p>
<p>由公式可得，线程等待时间所占比例越高，需要越多的线程，线程CPU时间所占比例越高，所需的线程数越少。</p>
<h3 id="14、socket-通信的基本流程"><a href="#14、socket-通信的基本流程" class="headerlink" title="14、socket 通信的基本流程"></a>14、socket 通信的基本流程</h3><p><img src="https://img-blog.csdnimg.cn/2cfc9fc18e144d3588dbf54e932055f2.png" alt="img"></p>
<h3 id="15、listen-函数第二个参数-backlog-参数作用"><a href="#15、listen-函数第二个参数-backlog-参数作用" class="headerlink" title="15、listen 函数第二个参数 backlog 参数作用"></a>15、listen 函数第二个参数 backlog 参数作用</h3><p>int listen(int sockfd, int backlog);<br> backlog是accept阻塞队列的长度，即等待accept的socket的最大数量。</p>
<h3 id="16、listen底层用的是什么队列"><a href="#16、listen底层用的是什么队列" class="headerlink" title="16、listen底层用的是什么队列"></a>16、listen底层用的是什么队列</h3><p>a.半连接队列（Incomplete connection queue），又称 SYN 队列。……</p>
<p>b.全连接队列（Completed connection queue），又称 Accept 队列。……</p>
<h3 id="17、send函数在发送的数据长度大于发送缓冲区大小，或者大于发送缓冲区剩余大小时，socket会怎么反应"><a href="#17、send函数在发送的数据长度大于发送缓冲区大小，或者大于发送缓冲区剩余大小时，socket会怎么反应" class="headerlink" title="17、send函数在发送的数据长度大于发送缓冲区大小，或者大于发送缓冲区剩余大小时，socket会怎么反应"></a>17、send函数在发送的数据长度大于发送缓冲区大小，或者大于发送缓冲区剩余大小时，socket会怎么反应</h3><p>不管是windows还是linux，阻塞还是非阻塞，send都会分帧发送，分帧到缓冲区能够接收的大小</p>
<h2 id="并发模型相关"><a href="#并发模型相关" class="headerlink" title="并发模型相关"></a>并发模型相关</h2><h3 id="1、IO是什么"><a href="#1、IO是什么" class="headerlink" title="1、IO是什么"></a>1、IO是什么</h3><p> 在计算机中，输入&#x2F;输出（即IO）是指信息处理系统（比如计算机）和外部世界（可以是人或其他信息处理系统）的通信。输入是指系统接收的信号或数据，输出是指从系统发出的数据或信号。</p>
<p>（数据从网卡或硬盘读到内核缓冲区）</p>
<h3 id="2、几种I-O模型"><a href="#2、几种I-O模型" class="headerlink" title="2、几种I&#x2F;O模型"></a>2、几种I&#x2F;O模型</h3><p>（1）阻塞 blocking  (BIO)</p>
<p>调用者调用了某个函数， 等待这个函数返回 ，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作。<br>（2）非阻塞 non-blocking（NIO）</p>
<p>非阻塞等待，每隔一段时间就去检测 IO 事件是否就绪。 没有就绪就可以做其他事。 非阻塞 I&#x2F;O 执行系统调 用总是立即返回，不管事件是否已经发生，若事件没有发生，则返回 -1 ，此时可以根据 errno 区分这两 种情况，对于 accept ， recv 和 send ，事件未发生时， errno 通常被设置成 EAGAIN 。<br>（3）IO复用（IO multiplexing）</p>
<p>Linux 用 select&#x2F;poll&#x2F;epoll 函数实现 IO 复用模型，这些函数也会使进程阻塞，但是和阻塞 IO 所不同的是这些函数可以同时阻塞多个 IO 操作。而且可以同时对多个读操作、写操作的 IO 函数进行检测。直到有数 据可读或可写时，才真正调用 IO 操作函数。<br>（4）信号驱动（signal-driven）</p>
<p>信号驱动 IO ， 安装一个信号处理函数，进程继续运行并不阻塞， 当 IO 事件就绪，进程收到 SIGIO 信号，然后处理 IO 事件。<br>与非阻塞 IO 的区别在于它提供了消息通知机制，不需要用户进程不断的轮询检查，减少了系统 API 的调用次数，提高了效率。<br>（5）异步（asynchronous）</p>
<p>Linux 中，可以调用 aio_read 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</p>
<h3 id="3、简单说一下服务器使用的并发模型？两种高效的事件并发处理模式reactor、proactor？"><a href="#3、简单说一下服务器使用的并发模型？两种高效的事件并发处理模式reactor、proactor？" class="headerlink" title="3、简单说一下服务器使用的并发模型？两种高效的事件并发处理模式reactor、proactor？"></a>3、简单说一下服务器使用的并发模型？两种高效的事件并发处理模式reactor、proactor？</h3><p>事件：I&#x2F;O事件、信号及定时事件</p>
<p>（1）reactor模式中，主线程(I&#x2F;O处理单元)只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程(逻辑单元 )，将socket可读写事件放入请求队列，交给工作线程处理，即读写数据、接受新连接及处理客户请求均在工作线程中完成。通常由同步I&#x2F;O实现（epoll_wait）。Reactor模式主要是提高系统的吞吐量，在有限的资源下处理更多的事情。</p>
<p>（2）proactor模式中，主线程和内核负责处理读写数据、接受新连接等I&#x2F;O操作，工作线程仅负责业务逻辑，如处理客户请求。通常由异步I&#x2F;O实现(aio_read&#x2F;aio_write)。</p>
<p>本服务器采用：同步I&#x2F;O模拟Proactor模式</p>
<p>Reactor和Proactor模式的主要区别就是 真正的读取和写入操作是有谁来完成的。</p>
<p>常见的 Reactor 实现方案有三种。</p>
<p>第一种方案单 Reactor 单进程 &#x2F; 线程，不用考虑进程间通信以及数据同步的问题，因此实现起来比较简单，这种方案的缺陷在于无法充分利用多核 CPU，而且处理业务逻辑的时间不能太长，否则会延迟响应，所以不适用于计算机密集型的场景，适用于业务处理快速的场景，比如 Redis 采用的是单 Reactor 单进程的方案。</p>
<p>第二种方案单 Reactor 多线程，通过多线程的方式解决了方案一的缺陷，但它离高并发还差一点距离，差在只有一个 Reactor 对象来承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方。</p>
<p>第三种方案多 Reactor 多进程 &#x2F; 线程，通过多个 Reactor 来解决了方案二的缺陷，主 Reactor 只负责监听事件，响应事件的工作交给了从 Reactor，Netty 和 Memcache 都采用了「多 Reactor 多线程」的方案，Nginx 则采用了类似于 「多 Reactor 多进程」的方案。</p>
<p>Reactor 可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」，而 Proactor 可以理解为「来了事件操作系统来处理，处理完再通知应用进程」。</p>
<p>因此，真正的大杀器还是 Proactor，它是采用异步 I&#x2F;O 实现的异步网络模型，感知的是已完成的读写事件，而不需要像 Reactor 感知到事件后，还需要调用 read 来从内核中获取数据。</p>
<p>不过，无论是 Reactor，还是 Proactor，都是一种基于「事件分发」的网络编程模式，区别在于 Reactor 模式是基于「待完成」的 I&#x2F;O 事件，而 Proactor 模式则是基于「已完成」的 I&#x2F;O 事件。</p>
<h3 id="4、你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？"><a href="#4、你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？" class="headerlink" title="4、你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？"></a>4、你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？</h3><p>（1）epoll的优点：epoll 是一种更加高效的 IO 复用技术</p>
<p>1、没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；<br>2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；<br>即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</p>
<p>3、 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</p>
<p>epoll 的使用步骤及原理如下：</p>
<p>1）调用epoll_create()会在内核中创建一个指示epoll内核事件表的文件描述符，该描述符将用作其他epoll系统调用的第一个参数。</p>
<p> 在这个结构体中有 2 个比较重要的数据成员：一个是需要检测的文件描述符的信息 struct_root rbr （红黑树），还有一个是就绪列表struct list_head rdlist，存放检测到数据发送改变的文件描述符信息 （双向链表）；</p>
<p>2）调用epoll_ctl() 用于操作内核事件表监控的文件描述符上的事件：注册、修改、删除</p>
<p>3）调用epoll_wait() 可以让内核去检测就绪的事件，并将就绪的事件放到就绪列表中并返回，通过返回的事件数组做进一步的事件处理。</p>
<p> epoll 的两种工作模式：</p>
<p>a）LT 模式（水平触发）LT（Level - Triggered）是缺省的工作方式，并且同时支持 Block 和 Nonblock Socket。 在这种做法中，内核检测到一个文件描述符就绪了，然后应用程序可以对这个就绪的 fd 进行 IO 操作。应用程序可以不立即处理该事件，如果不作任何操作，内核还是会继续通知。</p>
<p>b）ET 模式（边缘触发） ET（Edge - Triggered）是高速工作方式，只支持 Nonblock socket。 在这种模式下，epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序必须立即处理该事件。必须要一次性将数据读取完，使用非阻塞I&#x2F;O，读取到出现EAGAIN。但是，如果一直不对这个 fd 进行 IO 操作（从而导致它再次变成未就绪 ），内核不会发送更多的通知（only once）。</p>
<p> ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll 工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件描述符的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</p>
<p>3)EPOLLONESHOT</p>
<p>一个线程读取某个socket上的数据后开始处理数据，在处理过程中该socket上又有新数据可读，此时另一个线程被唤醒读取，此时出现两个线程处理同一个socket</p>
<p>我们期望的是一个socket连接在任一时刻都只被一个线程处理，通过epoll_ctl对该文件描述符注册epolloneshot事件，一个线程处理socket时，其他线程将无法处理，当该线程处理完后，需要通过epoll_ctl重置epolloneshot事件</p>
<p>（2）I&#x2F;O 多路复用是一种使得程序能同时监听多个文件描述符的技术，从而提高程序的性能。 Linux 下实现 I&#x2F;O 复用的系统调用主要有select、poll 和 epoll。</p>
<p> （3）select&#x2F;poll&#x2F;epoll区别 </p>
<p>1）调用函数</p>
<p>select和poll都是一个函数，epoll是一组函数</p>
<p>2）文件描述符数量</p>
<p>select通过线性表描述文件描述符集合，文件描述符有上限（与系统内存关系很大），32位机默认是1024个，64位机默认是2048。</p>
<p>poll是链表描述，突破了文件描述符上限，最大可以打开文件的数目</p>
<p>epoll通过红黑树描述，最大可以打开文件的数目</p>
<p>3）将文件描述符从用户传给内核</p>
<p>select和poll通过将所有文件描述符拷贝到内核态，每次调用都需要拷贝</p>
<p>epoll通过epoll_create建立一棵红黑树，通过epoll_ctl将要监听的文件描述符注册到红黑树上</p>
<p>4）内核判断就绪的文件描述符</p>
<p>select和poll通过线性遍历文件描述符集合，判断哪个文件描述符上有事件发生</p>
<p>epoll_create时，内核除了帮我们在epoll文件系统里建了个红黑树用于存储以后epoll_ctl传来的fd外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。</p>
<p>epoll是根据每个fd上面的回调函数(中断函数)判断，只有发生了事件的socket才会主动的去调用 callback函数，其他空闲状态socket则不会，若是就绪事件，插入list</p>
<p>5）应用程序索引就绪文件描述符</p>
<p>select&#x2F;poll只返回发生了事件的文件描述符的个数，若知道是哪个发生了事件，同样需要遍历</p>
<p>epoll返回的发生了事件的个数和结构体数组，结构体包含socket的信息，因此直接处理返回的数组即可</p>
<p>6）工作模式</p>
<p>select和poll都只能工作在相对低效的LT模式下</p>
<p>epoll则可以工作在ET高效模式，并且epoll还支持EPOLLONESHOT事件，该事件能进一步减少可读、可写和异常事件被触发的次数。 </p>
<p>7）应用场景</p>
<p>当监测的fd数目较小，且全部fd都比较活跃，建议使用select或者poll</p>
<p>当监测的fd数目非常大，且单位时间只有其中的一部分fd处于就绪状态，这个时候使用epoll能够明显提升性能</p>
<p>条件编译：</p>
<p>#ifdef 标识符</p>
<p>程序段1</p>
<p>#else</p>
<p>程序段2</p>
<p>#endif</p>
<h3 id="5、LT和ET的使用场景"><a href="#5、LT和ET的使用场景" class="headerlink" title="5、LT和ET的使用场景"></a>5、LT和ET的使用场景</h3><p>LT适用于并发量小的情况，ET适用于并发量大的情况。</p>
<p>ET在通知用户之后，就会将fd从就绪链表中删除，而LT不会，它会一直保留，这就会导致随着fd增多，就绪链表越大，每次都要从头开始遍历找到对应的fd，所以并发量越大效率越低。ET因为会删除所以效率比较高。</p>
<p>（LT模式下只读一次，ET模式下是无限循环读）</p>
<h3 id="6、怎么解决LT的缺点？"><a href="#6、怎么解决LT的缺点？" class="headerlink" title="6、怎么解决LT的缺点？"></a>6、怎么解决LT的缺点？</h3><p>LT模式下，可写状态的fd会一直触发事件，该怎么处理这个问题</p>
<p>数据量很少时直接send数据，数据量很多时每次要写数据时，将fd绑定EPOLLOUT事件，写完后将fd同EPOLLOUT从epoll中移除。</p>
<h3 id="7、为什么ET模式一定要设置非阻塞？"><a href="#7、为什么ET模式一定要设置非阻塞？" class="headerlink" title="7、为什么ET模式一定要设置非阻塞？"></a>7、为什么ET模式一定要设置非阻塞？</h3><p>因为ET模式下是无限循环读，直到出现错误为EAGAIN或者EWOULDBLOCK，这两个错误表示socket为空，然后就停止循环。如果是阻塞，循环读在socket为空的时候就会阻塞到那里，主线程的read（）函数一旦阻塞住，当再有其他监听事件过来就没办法读了，给其他事情造成了影响，所以必须要设置为非阻塞。</p>
<h3 id="8、epoll-如何判断数据已经读取完成"><a href="#8、epoll-如何判断数据已经读取完成" class="headerlink" title="8、epoll 如何判断数据已经读取完成"></a>8、epoll 如何判断数据已经读取完成</h3><p>epoll ET(Edge Trigger)模式，才需要关注数据是否读取完毕了。使用select或者epoll的LT模式，不用关注，select&#x2F;epoll检测到有数据可读去读就OK了。<br>两种做法：<br>1、针对TCP，调用recv方法，根据recv的返回值。如果返回值小于我们设定的recv buff的大小，那么就认为接收完毕。<br>2、TCP、UDP都适用，将socket设为NOBLOCK状态（使用fcntl函数），然后select该socket可读的时候，使用read&#x2F;recv函数读取数据。当返回值为-1，并且errno是EAGAIN或EWOULDBLOCK的时候，表示数据读取完毕。</p>
<h3 id="9、epoll为什么要用红黑树"><a href="#9、epoll为什么要用红黑树" class="headerlink" title="9、epoll为什么要用红黑树"></a>9、epoll为什么要用红黑树</h3><p>epoll内核中维护了一个内核事件表，它是将所有的文件描述符全部都存放在内核中，系统去检测有事件发生的时候触发回调，当你要添加新的文件描述符的时候也是调用epoll_ctl函数使用EPOLL_CTL_ADD宏来插入，epoll_wait也不是每次调用时都会重新拷贝一遍所有的文件描述符到内核态。当我现在要在内核中长久的维护一个数据结构来存放文件描述符，并且时常会有插入，查找和删除的操作发生，这对内核的效率会产生不小的影响，因此需要一种插入，查找和删除效率都不错的数据结构来存放这些文件描述符，那么红黑树当然是不二的人选。</p>
<h2 id="HTTP报文解析相关"><a href="#HTTP报文解析相关" class="headerlink" title="HTTP报文解析相关"></a>HTTP报文解析相关</h2><h3 id="1、用了状态机啊，为什么要用状态机？"><a href="#1、用了状态机啊，为什么要用状态机？" class="headerlink" title="1、用了状态机啊，为什么要用状态机？"></a>1、用了状态机啊，为什么要用状态机？</h3><p>在逻辑处理模块中，响应HTTP请求采用主从状态机来完成</p>
<p>传统的控制流程都是按照顺序执行的，状态机能处理任意顺序的事件，并能提供有意义的响应—即使这些事件发生的顺序和预计的不同。</p>
<p>项目中使用主从状态机的模式进行解析，从状态机（parse_line）负责读取报文的一行，主状态机负责对该行数据进行解析，主状态机内部调用从状态机，从状态机驱动主状态机。每解析一部分都会将整个请求的m_check_state状态改变，状态机也就是根据这个状态来进行不同部分的解析跳转的。</p>
<ol>
<li>当一个程序有多个状态时，规范了状态机的状态转换，避免了一些引入一些复杂的判断逻辑。</li>
<li>规范了程序在不同状态下所能提供的能力。 </li>
<li>在能力上可以进行横向扩展，提供新的状态来完善现有逻辑</li>
</ol>
<h3 id="2、状态机的转移图画一下"><a href="#2、状态机的转移图画一下" class="headerlink" title="2、状态机的转移图画一下"></a>2、状态机的转移图画一下</h3><p>从状态机负责读取报文的一行，主状态机负责对该行数据进行解析，主状态机内部调用从状态机，从状态机驱动主状态机。</p>
<p><img src="https://img-blog.csdnimg.cn/8490e9ceb6c044e0ae259dd41400fef7.png" alt="img"></p>
<p>主状态机</p>
<p>三种状态，标识解析位置。</p>
<p>CHECK_STATE_REQUESTLINE，解析请求行</p>
<p>CHECK_STATE_HEADER，解析请求头</p>
<p>CHECK_STATE_CONTENT，解析消息体，仅用于解析POST请求</p>
<p>从状态机</p>
<p>三种状态，标识解析一行的读取状态。</p>
<p>LINE_OK，完整读取一行，该条件涉及解析请求行和请求头部</p>
<p>LINE_BAD，报文语法有误</p>
<p>LINE_OPEN，读取的行不完整</p>
<h3 id="3、状态机的缺点"><a href="#3、状态机的缺点" class="headerlink" title="3、状态机的缺点"></a>3、状态机的缺点</h3><p>状态机的缺点就是性能比较低，一般一个状态做一个事情，性能比较差，在追求高性能的场景下一般不用，高性能场景一般使用流水线设计</p>
<h3 id="4、HTTPS协议为什么安全？"><a href="#4、HTTPS协议为什么安全？" class="headerlink" title="4、HTTPS协议为什么安全？"></a>4、HTTPS协议为什么安全？</h3><p><img src="https://img-blog.csdnimg.cn/20200703152027423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdqaWt1ZW4=,size_16,color_FFFFFF,t_70#pic_center" alt="https验证过程"></p>
<p>https共经历了两个阶段，一个是<strong>证书验证</strong>阶段，在本阶段通过<strong>非对称加密</strong>会验证ca证书的合法性，当证书合法之后，第二步是<strong>数据传输</strong>的阶段，本阶段的加密是使用对称加密，以用于高频传输数据，因为非对称加密相对于对称加密的效率是非常低的，高频传输根本无法接受这种情况</p>
<h3 id="5、HTTPS的SSL连接过程"><a href="#5、HTTPS的SSL连接过程" class="headerlink" title="5、HTTPS的SSL连接过程"></a>5、HTTPS的SSL连接过程</h3><h3 id="6、GET和POST的区别"><a href="#6、GET和POST的区别" class="headerlink" title="6、GET和POST的区别"></a>6、GET和POST的区别</h3><p>（1）get主要用来获取数据，post主要用来提交或修改数据。</p>
<p>（2）get的参数有长度限制，最长2048字节，而post没有限制。</p>
<p>（3）get是明文传输，可以直接通过url看到参数信息，post是放在请求体中，除非用工具才能看到。</p>
<p>（4）get的参数会附加在url中，以 “ ？”分割url和传输数据，多个参数用 “&amp;”连接， 而post会把参数放在http请求体中。</p>
<p>（5）get请求会保存在浏览器历史记录中，也可以保存在web服务器日志中。 </p>
<p>（6）get请求会被浏览器主动缓存，而post不会，除非手动设置。</p>
<p>（7）get在浏览器回退时是无害的，而post会再次提交请求。</p>
<p>（8）get请求只能进行url编码，而post支持多种编码方式。</p>
<p>（9）get请求的参数数据类型只接受ASCII字符，而post没有限制。</p>
<p>（10）get是幂等的，而post不是幂等的。 幂等性：对同一URL的多个请求应该返回同样的结果。</p>
<h3 id="7、HTTP报文格式"><a href="#7、HTTP报文格式" class="headerlink" title="7、HTTP报文格式"></a>7、HTTP报文格式</h3><p>（1）HTTP请求报文：请求行、请求头部、请求空行、请求数据</p>
<p><img src="https://img-blog.csdnimg.cn/639a989c851849f8bae613af4c6ba85d.png" alt="img"></p>
<p>1）请求行：用来说明请求方法,要访问的资源以及所使用的HTTP版本。</p>
<p>格式： 请求方法|空格|URL|空格|协议版本|回车符|换行符</p>
<p>2）请求头部：用来说明服务器要使用的附加信息</p>
<p>HTTP常见字段有哪些？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HOST，给出请求资源所在服务器的域名。</span><br></pre></td></tr></table></figure>

<p>   User-Agent，HTTP客户端程序的信息，该信息由你发出请求使用的浏览器来定义,并且在每个请求中自动发送等。</p>
<p>  connection，连接管理，可以是Keep-Alive或close。</p>
<p>  content-length字段，这里用于读取post请求的消息体长度</p>
<p> Content-Type 字段：用于服务器回应时，告诉客户端，本次数据是什么格式</p>
<p>Content-Type: text&#x2F;html; charset&#x3D;utf-8</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*POST /audiolibrary/music?ar=1595301089068&amp;n=1p1 HTTP/1.1\r\n*</span><br><span class="line">*Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, application/x-silverlight, application/x-shockwave-flash\r\n*</span><br><span class="line">*Referer: http://www.google.cn\r\n*</span><br><span class="line">*Accept-Language: zh-cn\r\n*</span><br><span class="line">*Accept-Encoding: gzip, deflate\r\n*</span><br><span class="line">*User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)\r\n*</span><br><span class="line">*content-length:28\r\n*</span><br><span class="line">*Host: www.google.cn\r\n*</span><br><span class="line">*Connection: Keep-Alive\r\n*</span><br><span class="line">*Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u\r\n&quot;*</span><br><span class="line">*\r\n*</span><br><span class="line">*hl=zh-CN&amp;source=hp&amp;q=domety</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; 上面的类型表明，发送的是网页，而且编码是UTF-8。<br>在HTTP报文中，每一行的数据由\r\n作为结束字符，空行则是仅仅是字符\r\n。因此，可以通过查找\r\n将报文拆解成单独的行进行解析</p>
<p>在报文中，请求头和空行的处理使用的同一个函数，这里通过判断当前的text首位是不是\0字符，若是，则表示当前处理的是空行，若不是，则表示当前处理的是请求头。判断是空行还是请求头，若是空行，进而判断content-length是否为0，如果不是0，表明是POST请求，则状态转移到CHECK_STATE_CONTENT，否则说明是GET请求，则报文解析结束。</p>
<p>（2）HTTP响应报文：状态行、响应头部、响应空行、响应正文</p>
<p>状态行：协议版本|空格|状态码|空格|状态码描述|回车符|换行符</p>
<h3 id="8、HTTP常用的请求方法"><a href="#8、HTTP常用的请求方法" class="headerlink" title="8、HTTP常用的请求方法"></a>8、HTTP常用的请求方法</h3><p>（１）HTTP1.0定义了三种请求方法： GET， POST 和 HEAD方法。</p>
<p>GET：请求获取资源</p>
<p>POST：提交或修改数据</p>
<p>HEAD：获得报文首部，与 GET 方法类似，只是不返回报文主体，一般用于验证 URI 是否有效。</p>
<p>（2）HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>
<p>OPTIONS：可使服务器传回该资源所支持的所有 HTTP 请求方法。</p>
<p>PUT：从客户端向服务器上传的数据取代指定的文件</p>
<p>DELETE：请求服务器删除指定的文件。</p>
<p>TRACE ：追踪路径。回显服务器收到的请求，主要用于测试或诊断。</p>
<p>CONNECT：HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器，通常用于SSL加密服务器的链接。</p>
<p>（３）HTTP2.0 新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在缺陷：文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。</p>
<h3 id="9、HTTP的协议版本"><a href="#9、HTTP的协议版本" class="headerlink" title="9、HTTP的协议版本"></a>9、HTTP的协议版本</h3><p>http协议目前有4个版本，其中1.0和1.1版本在互联网上被广泛使用，2.0版本目前应用很少，是下一代的http协议。</p>
<p>http&#x2F;0.9版本：原型版本，功能简陋，只有一个命令GET，服务器只能回应HTML格式字符串，该版本已过时。</p>
<p>http&#x2F;1.0版本：短连接</p>
<ul>
<li>任何格式的内容都可以发送，这使得互联网不仅可以传输文字，还能传输图像、视频、二进制等文件。</li>
<li>除了GET命令，还引入了POST命令和HEAD命令。</li>
<li>头信息是 ASCII码，而后面数据可为任何格式。服务器回应时会告诉客户端，数据是什么格式，即Content-Type字段的作用。Content-Type值：text&#x2F;xml image&#x2F;jpeg audio&#x2F;mp3</li>
<li>每个TCP连接只能发送一个请求，发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接</li>
</ul>
<p>HTTP1.1版本：是目前最为主流的http协议版本</p>
<ul>
<li>引入了持久连接（ persistent connection），即TCP连接默认不关闭，可以被多个请求复用</li>
<li>引入了管道机制（pipelining），即在同一个TCP连接里，客户端可以同时发送多个请求</li>
<li>新增方法：PUT、 PATCH、 OPTIONS、 DELETE</li>
</ul>
<p>HTTP2.0版本：发布于2015年，目前应用还比较少</p>
<ul>
<li>http&#x2F;2是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。</li>
<li>复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，避免了队头堵塞的问题。</li>
<li>HTTP&#x2F;2 允许服务器未经请求，主动向客户端发送资源，即服务器推送。</li>
<li>引入头信息压缩机制（header compression），头信息使用gzip或compress压缩后再发送；客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，不发送同样字段，只发送索引号，提高速度。</li>
</ul>
<h3 id="10、HTTP常见状态码及使用场景"><a href="#10、HTTP常见状态码及使用场景" class="headerlink" title="10、HTTP常见状态码及使用场景"></a>10、HTTP常见状态码及使用场景</h3><p>1xx消息——请求已被服务器接收，继续处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">101 切换请求协议，从 HTTP 切换到 WebSocket</span><br></pre></td></tr></table></figure>

<p>2xx成功——请求已成功被服务器接收、理解、并接受</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">200 请求成功，有响应体</span><br></pre></td></tr></table></figure>

<p>3xx重定向——需要后续操作才能完成这一请求</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">300</span> 可选重定向</span><br><span class="line"><span class="number">301</span> 永久重定向：会缓存</span><br><span class="line"><span class="number">302</span> 临时重定向：不会缓存</span><br><span class="line"><span class="number">304</span> 协商缓存命中</span><br></pre></td></tr></table></figure>

<p>4xx请求错误——请求含有语法错误或者无法被执行</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">400</span> 请求报文存在语法错误</span><br><span class="line"><span class="number">404</span> 资源未找到</span><br><span class="line"><span class="number">403</span> 服务器禁止访问</span><br></pre></td></tr></table></figure>

<p>5xx服务器错误——服务器在处理某个正确请求时发生错误</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">500</span> 服务器端错误</span><br><span class="line"><span class="number">503</span> 服务器繁忙</span><br><span class="line"><span class="number">504</span> 网关超时</span><br></pre></td></tr></table></figure>

<h3 id="11、HTTP状态码301和302的区别"><a href="#11、HTTP状态码301和302的区别" class="headerlink" title="11、HTTP状态码301和302的区别"></a>11、HTTP状态码301和302的区别</h3><p>301 永久重定向：页面永久性转移，表示为资源或页面永久性地转移到了另一个位置。</p>
<p>（1）用于防止收藏夹中的旧地址因网页扩展名改变而出错</p>
<p>（2）用于多个域名跳转至同一域名</p>
<p>302 临时重定向：页面暂时性转移，表示资源或页面暂时转移到另一个位置</p>
<p>用作网址劫持，容易导致网站降权，严重时网站会被封掉，不推荐使用</p>
<h3 id="12、一次完整-HTTP-请求所经历的步骤"><a href="#12、一次完整-HTTP-请求所经历的步骤" class="headerlink" title="12、一次完整 HTTP 请求所经历的步骤"></a>12、一次完整 HTTP 请求所经历的步骤</h3><p>（当我们在 web 浏览器的地址栏中输入：<a href="http://www.baidu.com，然后回车，到底发生了什么？）">www.baidu.com，然后回车，到底发生了什么？）</a></p>
<p>由域名→ IP 地址 寻找 IP 地址的过程依次经过了浏览器缓存、系统缓存、hosts 文件、路由器缓存、 递归搜索根域名服务器（DNS解析）。</p>
<p>建立 TCP&#x2F;IP 连接（三次握手具体过程）。</p>
<p>由浏览器发送一个 HTTP 请求。</p>
<p>经过路由器的转发，通过服务器的防火墙，该 HTTP 请求到达了服务器。</p>
<p>服务器处理该 HTTP 请求，返回一个 HTML 文件。</p>
<p>浏览器解析该 HTML 文件，并且显示在浏览器端。</p>
<p>服务器关闭 TCP 连接（四次挥手具体过程）。</p>
<h3 id="13、HTTP与HTTPS的缺点，以及区别"><a href="#13、HTTP与HTTPS的缺点，以及区别" class="headerlink" title="13、HTTP与HTTPS的缺点，以及区别"></a>13、HTTP与HTTPS的缺点，以及区别</h3><p>（1）HTTP 的不足</p>
<p>窃听风险： 通信使用明文(不加密),内容可能会被窃听；</p>
<p>冒充风险： 不验证通信方的身份,因此有可能遭遇伪装；</p>
<p>篡改风险： 无法证明报文的完整性,所以有可能已遭篡改；</p>
<p>（2）HTTPS 的缺点</p>
<p>HTTPS 协议多次握手，导致页面的加载时间延长近 50%；</p>
<p>HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗；</p>
<p>SSL 涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大；</p>
<p>（3）区别</p>
<p>端口不同：HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443；</p>
<p>资源消耗：HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议，需要消耗更多的 CPU 和内存资源</p>
<p>开销：HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费；</p>
<p>安全性：HTTP 的连接很简单，是无状态的；HTTPS 协议是由 TLS+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全</p>
<h3 id="14、HTTP报文处理流程"><a href="#14、HTTP报文处理流程" class="headerlink" title="14、HTTP报文处理流程"></a>14、HTTP报文处理流程</h3><p>·  浏览器端发出http连接请求，主线程创建http对象接收请求并将所有数据读入对应buffer，将该对象插入任务队列，工作线程从任务队列中取出一个任务进行处理。</p>
<p>·  工作线程取出任务后，调用process_read函数，通过主、从状态机对请求报文进行解析。</p>
<p>·  解析完之后，跳转do_request函数生成响应报文，通过process_write写入buffer，返回给浏览器端。</p>
<h2 id="定时器相关"><a href="#定时器相关" class="headerlink" title="定时器相关"></a>定时器相关</h2><h3 id="1、为什么要用定时器？"><a href="#1、为什么要用定时器？" class="headerlink" title="1、为什么要用定时器？"></a>1、为什么要用定时器？</h3><p>为了定期删除非活跃事件，防止连接资源的浪费。</p>
<p>非活跃，是指浏览器与服务器端建立连接后，长时间不交换数据，一直占用服务器端的文件描述符，导致连接资源的浪费。</p>
<p>定时事件，是指固定一段时间之后触发某段代码，由该段代码处理一个事件，如从内核事件表删除事件，并关闭文件描述符，释放连接资源。</p>
<h3 id="2、说一下定时器的工作原理"><a href="#2、说一下定时器的工作原理" class="headerlink" title="2、说一下定时器的工作原理"></a>2、说一下定时器的工作原理</h3><p> 定时器利用结构体将定时事件进行封装起来。定时事件，即定期检测非活跃连接。</p>
<p>服务器主循环为每一个连接创建一个定时器，并对每个连接进行定时。另外，利用升序双向链表将所有定时器串联起来，利用alarm函数周期性地触发SIGALRM信号，信号处理函数利用管道通知主循环，主循环接收到该信号后对升序链表上所有定时器进行处理，若该段时间内没有交换数据，则将该连接关闭，释放所占用的资源。（信号处理函数仅仅发送信号通知程序主循环，将信号对应的处理逻辑放在程序主循环中，由主循环执行信号对应的逻辑代码。）</p>
<p>信号通知的逻辑：创建管道，其中管道写端写入信号值，管道读端通过I&#x2F;O复用系统监测读事</p>
<p>为什么管道写端要非阻塞？</p>
<p>send是将信息发送给套接字缓冲区，如果缓冲区满了，则会阻塞，这时候会进一步增加信号处理函数的执行时间，为此，将其修改为非阻塞。</p>
<h3 id="3、定时任务处理函数的逻辑"><a href="#3、定时任务处理函数的逻辑" class="headerlink" title="3、定时任务处理函数的逻辑"></a>3、定时任务处理函数的逻辑</h3><p>使用统一事件源，SIGALRM信号每次被触发，主循环中调用一次定时任务处理函数，处理链表容器中到期的定时器。</p>
<p>（1）链表容器是升序排列，当前时间小于定时器的超时时间，后面的定时器也没有到期</p>
<p>（2）当前定时器到期，则调用回调函数，执行定时事件</p>
<p>（3）将处理后的定时器从链表容器中删除，并重置头结点</p>
<p>若有数据传输，则将定时器往后延迟3个单位</p>
<h3 id="4、升序双向链表，删除和添加的时间复杂度说一下？还可以优化吗？"><a href="#4、升序双向链表，删除和添加的时间复杂度说一下？还可以优化吗？" class="headerlink" title="4、升序双向链表，删除和添加的时间复杂度说一下？还可以优化吗？"></a>4、升序双向链表，删除和添加的时间复杂度说一下？还可以优化吗？</h3><p>删除定时器的时间复杂度是O(1)，添加定时器的时间复杂度是O(n)（刚好添加在尾节点时）。</p>
<p>缺点：每次以固定的时间间隔触发SIGALRM信号，调用定时任务处理函数处理超时连接会造成一定的触发浪费。举个例子，若当前的TIMESLOT&#x3D;5，即每隔5ms触发一次SIGALRM，跳出循环执行定时任务处理函数，这时如果当前即将超时的任务距离现在还有20ms，那么在这个期间，SIGALRM信号被触发了4次，定时任务处理函数也被执行了4次，可是在这4次中，前三次触发都是无意义的。</p>
<p>（1）在双向链表的基础上优化：</p>
<p>在添加新定时器时，除了检测新定时器是否小于头节点定时器，还应该检测是否大于尾节点定时器的时间，都不符合再使用常规插入。</p>
<p>（2）不使用双向链表优化：最小堆。</p>
<h5 id="5、最小堆优化？说一下时间复杂度和工作原理"><a href="#5、最小堆优化？说一下时间复杂度和工作原理" class="headerlink" title="5、最小堆优化？说一下时间复杂度和工作原理"></a>5、最小堆优化？说一下时间复杂度和工作原理</h5><h3 id="时间复杂度：添加：O-logn-，-删除：O-1"><a href="#时间复杂度：添加：O-logn-，-删除：O-1" class="headerlink" title="时间复杂度：添加：O(logn)， 删除：O(1)"></a>时间复杂度：添加：O(logn)， 删除：O(1)</h3><p>工作原理：</p>
<p>将所有定时器中超时时间最小的一个定时器的超时值作为定时任务处理函数的定时值。这样，一旦定时任务处理函数被调用，超时时间最小的定时器必然到期，我们就可以在定时任务处理函数中处理该定时器。然后，再次从剩余的定时器中找出超时时间最小的一个（堆），并将这段最小时间设置为下一次定时任务处理函数的定时值。如此反复，就实现了较为精确的定时。</p>
<h2 id="日志相关"><a href="#日志相关" class="headerlink" title="日志相关"></a>日志相关</h2><h3 id="1、说下你的日志系统的运行机制？"><a href="#1、说下你的日志系统的运行机制？" class="headerlink" title="1、说下你的日志系统的运行机制？"></a>1、说下你的日志系统的运行机制？</h3><p>使用单例模式创建日志系统，对服务器运行状态、错误信息和访问数据进行记录，该系统可以实现按天分类，超行分类功能，可以根据实际情况分别使用同步和异步写入两种方式。</p>
<p>其中异步写入方式，将生产者-消费者模型封装为阻塞队列，创建一个写线程，工作线程将要写的内容push进队列，写线程从队列中取出内容，写入日志文件。</p>
<p>超行、按天分文件逻辑，具体的，</p>
<p>日志写入前会判断当前day是否为创建日志的时间，行数是否超过最大行限制<br>若为创建日志时间，写入日志，否则按当前时间创建新log，更新创建时间和行数<br>若行数超过最大行限制，在当前日志的末尾加count&#x2F;max_lines为后缀创建新log</p>
<h3 id="2、为什么要异步？和同步的区别是什么？"><a href="#2、为什么要异步？和同步的区别是什么？" class="headerlink" title="2、为什么要异步？和同步的区别是什么？"></a>2、为什么要异步？和同步的区别是什么？</h3><p>生产者-消费者模型，并发编程中的经典模型。</p>
<p>以多线程为例，为了实现线程间数据同步，生产者线程与消费者线程共享一个缓冲区，其中生产者线程往缓冲区中push消息，消费者线程从缓冲区中pop消息。</p>
<p>阻塞队列，将生产者-消费者模型进行封装，使用循环数组实现队列，作为两者共享的缓冲区。</p>
<p>异步日志，将所写的日志内容先存入阻塞队列，写线程从阻塞队列中取出内容，写入日志。</p>
<p>可以提高系统的并发性能。</p>
<p> 同步日志，日志写入函数与工作线程串行执行，由于涉及到I&#x2F;O操作，当单条日志比较大的时候，同步模式会阻塞整个处理流程，服务器所能处理的并发能力将有所下降，尤其是在峰值的时候，写日志可能成为系统的瓶颈。</p>
<p>写入方式通过初始化时是否设置队列大小（表示在队列中可以放几条数据）来判断，若队列大小为0，则为同步，否则为异步。</p>
<p>若异步,则将日志信息加入阻塞队列,同步则加锁向文件中写</p>
<h3 id="3、关于该项目用到的设计模式"><a href="#3、关于该项目用到的设计模式" class="headerlink" title="3、关于该项目用到的设计模式"></a>3、关于该项目用到的设计模式</h3><p>（1）单例模式：单例对象的类只能允许一个实例存在，并提供一个访问它的全局访问点，该实例被所有程序模块共享。主要解决一个全局使用的类频繁的创建和销毁的问题，是一种创建型模式，提供了一种创建对象的最佳方式。</p>
<p>（2）单例模式三要素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1）单例类只能有一个实例。</span><br><span class="line"></span><br><span class="line">2）单例类必须自己创建自己的唯一实例。</span><br><span class="line"></span><br><span class="line">3）单例类必须给所有其他对象提供这一实例。</span><br></pre></td></tr></table></figure>

<p>（3）单例设计模式的优缺点<br>优点：<br>1 ）单例模式可以保证内存里 只有一个实例 ， 减少了内存的开销 。<br>2 ）可以避免对资源的 多重占用 。 （比如写文件操作）<br>3 ）单例模式设置全局访问点，可以优化和共享资源的访问。<br>缺点：<br>1 ）单例模式一般没有接口， 不能继承， 扩展困难 。 如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。<br>2 ）在并发测试中，单例模式 不利于代码调试 。 在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。<br>3 ）单例模式的功能代码通常写在一个类中， 如果功能设计不合理，则很容易违背单一职责原则。<br>（4）C++ 单例设计模式的实现 两步骤<br>1 ） 私有化 构造函数 ，这样别处的代码就无法通过调用该类的构造函数来实例化该类的对象，只 有通过该类提供的静态方法来得到 该类的唯一实例 ；<br>2 ） 通过局部静态变量，利用其只初始化一次的特点，返回静态对象成员。<br>（5） 单例设计模式的种类<br>1 ）懒汉式：获取该类的对象 时 才创建该类的实例<br>2 ）饿汉式：获取该类的对象之 前 已经创建好该类的实例<br>（6）手撕单例模式<br>（懒汉模式）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">single</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">single</span>()&#123;&#125;   <span class="comment">// 私有化构造函数</span></span><br><span class="line">    ~<span class="built_in">single</span>()&#123;&#125;  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 公有静态方法获取实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> single* <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">single* <span class="title">single::getinstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> single obj;</span><br><span class="line">    <span class="keyword">return</span> &amp;obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 使用函数内的局部静态对象无需加锁和解锁，因为C++11后编译器可以保证内部静态变量的线程安全性</p>
<p>（懒汉模式）加锁版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">single</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_mutex_t</span> lock;</span><br><span class="line">    <span class="built_in">single</span>()&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;lock, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">single</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> single* <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">pthread_mutex_t</span> single::lock;</span><br><span class="line"><span class="function">single* <span class="title">single::getinstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;lock);</span><br><span class="line">    <span class="type">static</span> single obj;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;lock);</span><br><span class="line">    <span class="keyword">return</span> &amp;obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（饿汉模式）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class single&#123;</span><br><span class="line">private:</span><br><span class="line">    static single* p;</span><br><span class="line">    single()&#123;&#125;</span><br><span class="line">    ~single()&#123;&#125;</span><br><span class="line">public:</span><br><span class="line">    static single* getinstance();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">single* single::p = new single();</span><br><span class="line">single* single::getinstance()&#123;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 饿汉模式不需要用锁，就可以实现线程安全。原因在于，在程序运行时就定义了对象，并对其初始化。之后，不管哪个线程调用成员函数getinstance()，都只是返回一个对象的指针</p>
<h3 id="4、现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上？（消息队列）"><a href="#4、现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上？（消息队列）" class="headerlink" title="4、现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上？（消息队列）"></a>4、现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上？（消息队列）</h3><h2 id="数据库登录注册相关"><a href="#数据库登录注册相关" class="headerlink" title="数据库登录注册相关"></a>数据库登录注册相关</h2><h3 id="1、-什么是数据库连接池，为什么要创建连接池？"><a href="#1、-什么是数据库连接池，为什么要创建连接池？" class="headerlink" title="1、 什么是数据库连接池，为什么要创建连接池？"></a>1、 什么是数据库连接池，为什么要创建连接池？</h3><p>（1）池是资源的容器，本质上是对资源的复用。</p>
<p>当系统开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，无需动态分配；当服务器处理完一个客户连接后,可以把相关的资源放回池中，无需执行系统调用释放资源。</p>
<p>（2）若系统需要频繁访问数据库，则需要频繁创建和断开数据库连接，而创建数据库连接是一个很耗时的操作，也容易对数据库造成安全隐患。</p>
<p>在程序初始化的时候，集中创建多个数据库连接，并把他们集中管理，供程序使用，可以保证较快的数据库读写速度，更加安全可靠。</p>
<p>（3）使用单例模式和链表创建数据库连接池，实现对数据库连接资源的复用。</p>
<p>连接池的功能主要有：初始化，获取连接、释放连接，销毁连接池</p>
<p>连接池中的多线程使用信号量进行通信，使用互斥锁进行同步。</p>
<p>数据库连接的获取与释放通过RAII机制封装，避免手动释放。</p>
<p> RAII机制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”.</span><br><span class="line">RAII的核心思想是将资源或者状态与对象的生命周期绑定，通过C++的语言机制，实现资源和状态的安全管理,智能指针是RAII最好的例子</span><br><span class="line">具体来说：构造函数的时候初始化获取资源，析构函数释放资源</span><br></pre></td></tr></table></figure>



<h3 id="2、登录说一下？（登录注册是POST请求）"><a href="#2、登录说一下？（登录注册是POST请求）" class="headerlink" title="2、登录说一下？（登录注册是POST请求）"></a>2、登录说一下？（登录注册是POST请求）</h3><p>将数据库中的用户名和密码载入到服务器的map中来，map中的key为用户名，value为密码</p>
<p>服务器端解析浏览器的请求报文，当解析为POST请求时，提取出请求报文的消息体的用户名和密码。</p>
<p>POST请求中最后是用户名和密码，用&amp;隔开。分隔符&amp;，前是用户名，后是密码。</p>
<p>登录：将浏览器输入的用户名和密码在数据库中查找，直接判断。</p>
<p>注册：往数据库中插入数据，需要判断是否有重复的用户名。</p>
<p>最后进行页面跳转</p>
<p>通过m_url定位&#x2F;所在位置，根据&#x2F;后的第一个字符，使用分支语句实现页面跳转。具体的，</p>
<p>0 — 跳转注册页面，GET<br>1 — 跳转登录页面，GET<br>5 — 显示图片页面，POST<br>6 — 显示视频页面，POST<br>7 — 显示关注页面，POST</p>
<h3 id="3、登录验证怎么写的？用户登录需要考虑什么？"><a href="#3、登录验证怎么写的？用户登录需要考虑什么？" class="headerlink" title="3、登录验证怎么写的？用户登录需要考虑什么？"></a>3、登录验证怎么写的？用户登录需要考虑什么？</h3><h3 id="4、你这个保存状态了吗？如果要保存，你会怎么做？（cookie和session）"><a href="#4、你这个保存状态了吗？如果要保存，你会怎么做？（cookie和session）" class="headerlink" title="4、你这个保存状态了吗？如果要保存，你会怎么做？（cookie和session）"></a>4、你这个保存状态了吗？如果要保存，你会怎么做？（cookie和session）</h3><h3 id="5、登录中的用户名和密码你是load到本地，然后使用map匹配的，如果有10亿数据，即使load到本地后hash，也是很耗时的，你要怎么优化？"><a href="#5、登录中的用户名和密码你是load到本地，然后使用map匹配的，如果有10亿数据，即使load到本地后hash，也是很耗时的，你要怎么优化？" class="headerlink" title="5、登录中的用户名和密码你是load到本地，然后使用map匹配的，如果有10亿数据，即使load到本地后hash，也是很耗时的，你要怎么优化？"></a>5、登录中的用户名和密码你是load到本地，然后使用map匹配的，如果有10亿数据，即使load到本地后hash，也是很耗时的，你要怎么优化？</h3><h3 id="6、用的mysql啊，redis了解吗？用过吗？"><a href="#6、用的mysql啊，redis了解吗？用过吗？" class="headerlink" title="6、用的mysql啊，redis了解吗？用过吗？"></a>6、用的mysql啊，redis了解吗？用过吗？</h3><h2 id="压测相关"><a href="#压测相关" class="headerlink" title="压测相关"></a>压测相关</h2><h3 id="1、服务器并发量测试过吗？怎么测试的？"><a href="#1、服务器并发量测试过吗？怎么测试的？" class="headerlink" title="1、服务器并发量测试过吗？怎么测试的？"></a>1、服务器并发量测试过吗？怎么测试的？</h3><p>补充知识：</p>
<p>系统吞吐量几个重要参数：QPS（TPS）、并发数、响应时间</p>
<p>TPS：Transactions Per Second，即服务器每秒响应的事务数</p>
<p>QPS：每秒查询率，每秒的响应请求数量</p>
<p>并发数： 系统同时处理的request&#x2F;事务数</p>
<p>响应时间： 一般取平均响应时间</p>
<p>关系：QPS（TPS）&#x3D; 并发数&#x2F;平均响应时间</p>
<p>压力测试：每分响应请求数pages&#x2F;min  和 每秒传输数据量bytes&#x2F;sec</p>
<p>使用Webbench对服务器进行压力测试，创建1000个客户端，并发访问服务器10s，正常情况下有接近8万个HTTP请求访问服务器。</p>
<h3 id="2、webbench是什么？介绍一下原理"><a href="#2、webbench是什么？介绍一下原理" class="headerlink" title="2、webbench是什么？介绍一下原理"></a>2、webbench是什么？介绍一下原理</h3><p>WebBench是一款在Linux下使用非常简单的压力测试工具。</p>
<p>原理：WebBench首先fork出多个子进程，每个子进程都循环做web访问测试。子进程把访问的结果通过pipe告诉父进程，父进程做最终的统计结果。Webbench最多可以模拟3万个并发连接去测试网站的负载能力。 </p>
<p>-c ：子进程的个数，即并发数</p>
<p>-t ：运行webbench的时间</p>
<h3 id="3、测试的时候有没有遇到问题？"><a href="#3、测试的时候有没有遇到问题？" class="headerlink" title="3、测试的时候有没有遇到问题？"></a>3、测试的时候有没有遇到问题？</h3><p> Bug：使用Webbench对服务器进行压力测试，创建1000个客户端，并发访问服务器10s，正常情况下有接近8万个HTTP请求访问服务器。</p>
<p>结果显示仅有7个请求被成功处理，0个请求处理失败，服务器也没有返回错误。此时，从浏览器端访问服务器，发现该请求也不能被处理和响应，必须将服务器重启后，浏览器端才能访问正常。</p>
<p>解决办法：</p>
<p>排查：</p>
<p>通过查询服务器运行日志，对服务器接收HTTP请求连接，HTTP处理逻辑两部分进行排查。</p>
<p>日志中显示，7个请求报文为:GET &#x2F; HTTP&#x2F;1.0的HTTP请求被正确处理和响应，排除HTTP处理逻辑错误。重点放在接收HTTP请求连接部分。其中，服务器端接收HTTP请求的连接步骤为socket -&gt; bind -&gt; listen -&gt; accept</p>
<p>错误原因：错误使用epoll的ET模式。</p>
<p>ET边缘触发模式</p>
<p>epoll_wait检测到文件描述符有事件发生，则将其通知给应用程序，应用程序必须立即处理该事件。</p>
<p>必须要一次性将数据读取完，使用非阻塞I&#x2F;O，读取到出现eagain。</p>
<p>当连接较少时，队列不会变满，即使listenfd设置成ET非阻塞，不使用while一次性读取完，也不会出现Bug。</p>
<p>若此时1000个客户端同时对服务器发起连接请求，连接过多会造成established 状态的连接队列变满。但accept并没有使用while一次性读取完，只读取一个。因此，连接过多导致TCP就绪队列中剩下的连接都得不到处理，同时新的连接也不会到来。</p>
<p>解决方案</p>
<p>将listenfd设置成LT阻塞，或者ET非阻塞模式下while包裹accept即可解决问题。</p>
<h2 id="综合能力"><a href="#综合能力" class="headerlink" title="综合能力"></a>综合能力</h2><h3 id="1、你的项目解决了哪些其他同类项目没有解决的问题？"><a href="#1、你的项目解决了哪些其他同类项目没有解决的问题？" class="headerlink" title="1、你的项目解决了哪些其他同类项目没有解决的问题？"></a>1、你的项目解决了哪些其他同类项目没有解决的问题？</h3><h3 id="2、说一下前端发送请求后，服务器处理的过程，中间涉及哪些协议？"><a href="#2、说一下前端发送请求后，服务器处理的过程，中间涉及哪些协议？" class="headerlink" title="2、说一下前端发送请求后，服务器处理的过程，中间涉及哪些协议？"></a>2、说一下前端发送请求后，服务器处理的过程，中间涉及哪些协议？</h3>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/08/04/linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" rel="prev" title="linux 常用命令">
      <i class="fa fa-chevron-left"></i> linux 常用命令
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#title-C-%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%EF%BC%88%E5%90%AB%E4%BB%A3%E7%A0%81%E9%A2%98%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">title: C++开发常见面试题整理（含代码题）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C"><span class="nav-number"></span> <span class="nav-text">C++</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-C%E5%92%8CC-%E5%8C%BA%E5%88%AB"><span class="nav-number">1.</span> <span class="nav-text">1. C和C++区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.</span> <span class="nav-text">2. static关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-cast%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.</span> <span class="nav-text">3. cast转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">4.</span> <span class="nav-text">4. volatile关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-explicit"><span class="nav-number">5.</span> <span class="nav-text">5. explicit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-C-C-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8"><span class="nav-number">6.</span> <span class="nav-text">6. C&#x2F;C++指针和引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">7.</span> <span class="nav-text">7. C++智能指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84"><span class="nav-number">8.</span> <span class="nav-text">8. 指针和数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8"><span class="nav-number">9.</span> <span class="nav-text">9. 指针和引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0"><span class="nav-number">10.</span> <span class="nav-text">10.  函数指针和指针函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E6%9E%90%E6%9E%84-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">11.</span> <span class="nav-text">11. 析构&amp;构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E9%87%8D%E8%BD%BD%E5%92%8C%E8%A6%86%E7%9B%96"><span class="nav-number">12.</span> <span class="nav-text">12. 重载和覆盖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81"><span class="nav-number">13.</span> <span class="nav-text">13. 虚函数和多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-new-malloc"><span class="nav-number">14.</span> <span class="nav-text">14. new&amp;malloc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-number">15.</span> <span class="nav-text">15. 初始化列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-C-11"><span class="nav-number">16.</span> <span class="nav-text">16. C++11</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-vector%E3%80%81array%E3%80%81%E6%95%B0%E7%BB%84"><span class="nav-number">17.</span> <span class="nav-text">17. vector、array、数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-std-function-bind"><span class="nav-number">18.</span> <span class="nav-text">18. std::function bind</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">19.</span> <span class="nav-text">19. lambda 表达式:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-const"><span class="nav-number">20.</span> <span class="nav-text">20. const</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-inline%E5%92%8Cdefine"><span class="nav-number">21.</span> <span class="nav-text">21 inline和define</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E5%92%8C%E7%AE%97%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">容器和算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-map-set-%E5%8C%BA%E5%88%AB%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.</span> <span class="nav-text">1. map &amp;set 区别和实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-STL-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-number">2.</span> <span class="nav-text">2. STL 迭代器删除元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-vector-%E5%92%8C-list"><span class="nav-number">3.</span> <span class="nav-text">3.vector 和 list</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E6%8C%87%E9%92%88"><span class="nav-number">4.</span> <span class="nav-text">4. 迭代器、指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-resize-%E5%92%8C-reserve"><span class="nav-number">5.</span> <span class="nav-text">5. resize 和 reserve</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%94%BE%E5%85%A5vector%E7%B1%BB%E7%9A%84%E8%A6%81%E6%B1%82"><span class="nav-number">6.</span> <span class="nav-text">6.放入vector类的要求</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#OS"><span class="nav-number"></span> <span class="nav-text">OS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%B7%A6%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">1. 左右值引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-C-%E6%BA%90%E6%96%87%E4%BB%B6to%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="nav-number">2.</span> <span class="nav-text">2.  C++源文件to可执行文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%A4%B4%E6%96%87%E4%BB%B6%E2%80%9D%E2%80%9D%E5%92%8C"><span class="nav-number">3.</span> <span class="nav-text">3.头文件””和&lt;&gt;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-malloc"><span class="nav-number">4.</span> <span class="nav-text">4. malloc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text">5.程序内存管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E3%80%81%E6%BA%A2%E5%87%BA"><span class="nav-number">6.</span> <span class="nav-text">6.内存泄漏、溢出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-number">7.</span> <span class="nav-text">7. 进程与线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-number">8.</span> <span class="nav-text">8. 进程通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-number">9.</span> <span class="nav-text">9. 线程通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">10.</span> <span class="nav-text">10.虚拟内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD"><span class="nav-number">11.</span> <span class="nav-text">11.缺页中断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="nav-number">12.</span> <span class="nav-text">12. 并发和并行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E6%AD%BB%E9%94%81"><span class="nav-number">13.</span> <span class="nav-text">13. 死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-%E7%BB%93%E6%9E%84%E4%BD%93%E5%AF%B9%E9%BD%90"><span class="nav-number">14.</span> <span class="nav-text">14. 结构体对齐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2"><span class="nav-number">15.</span> <span class="nav-text">15. 虚拟内存页面置换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-%E9%94%81"><span class="nav-number">16.</span> <span class="nav-text">16. 锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF"><span class="nav-number">17.</span> <span class="nav-text">17.大端小端</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-%E7%94%A8%E6%88%B7%E3%80%81%E5%86%85%E6%A0%B8%E6%80%81"><span class="nav-number">18.</span> <span class="nav-text">18.用户、内核态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-%E5%BE%AE%E5%86%85%E6%A0%B8-%E5%AE%8F%E5%86%85%E6%A0%B8"><span class="nav-number">19.</span> <span class="nav-text">19.微内核 宏内核</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-%E5%83%B5%E5%B0%B8%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="nav-number">20.</span> <span class="nav-text">20.僵尸孤儿进程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C"><span class="nav-number"></span> <span class="nav-text">网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">1.</span> <span class="nav-text">1.三次握手、四次挥手</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-TCP%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-number">2.</span> <span class="nav-text">2.TCP可靠性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-HTTP%E3%80%81HTTPS"><span class="nav-number">3.</span> <span class="nav-text">3.HTTP、HTTPS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-HTTP-%E8%BF%94%E5%9B%9E%E7%A0%81"><span class="nav-number">4.</span> <span class="nav-text">4. HTTP 返回码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-OSI-7%E5%B1%82%E5%92%8CTCP-4%E5%B1%82"><span class="nav-number">5.</span> <span class="nav-text">5.OSI 7层和TCP 4层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-URL%E6%AD%A5%E9%AA%A4"><span class="nav-number">6.</span> <span class="nav-text">6. URL步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-TCP%E3%80%81UDP"><span class="nav-number">7.</span> <span class="nav-text">7. TCP、UDP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-socket%E5%87%BD%E6%95%B0"><span class="nav-number">8.</span> <span class="nav-text">8. socket函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#code-%E7%BD%91%E7%BB%9C%EF%BC%86OS"><span class="nav-number"></span> <span class="nav-text">code-网络＆OS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%B8%BB%E5%AD%90%E8%BD%AE%E6%B5%81%E8%BE%93%E5%87%BA"><span class="nav-number">1.</span> <span class="nav-text">1. 主子轮流输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%B8%89%E7%BA%BF%E7%A8%8B%E8%BE%93%E5%87%BAABC"><span class="nav-number">2.</span> <span class="nav-text">2.三线程输出ABC</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E9%A2%98"><span class="nav-number"></span> <span class="nav-text">代码题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E9%93%BE%E8%A1%A8"><span class="nav-number">1.</span> <span class="nav-text">一、链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">1.1.</span> <span class="nav-text">1. 反转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. 1 反转链表 II</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">1.2.</span> <span class="nav-text">3. 合并两个有序链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="nav-number">1.3.</span> <span class="nav-text">4. 环形链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%85%A1-%E8%BF%94%E5%9B%9E%E4%BA%A4%E7%82%B9"><span class="nav-number">1.3.1.</span> <span class="nav-text">Ⅱ 返回交点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="nav-number">1.4.</span> <span class="nav-text">5. 相交链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">1.5.</span> <span class="nav-text">6. 合并K个有序链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8"><span class="nav-number">1.6.</span> <span class="nav-text">7. 重排链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92-N-%E7%BB%93%E7%82%B9"><span class="nav-number">1.7.</span> <span class="nav-text">8. 删除链表的倒 N 结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8-%E5%BD%92%E5%B9%B6"><span class="nav-number">1.8.</span> <span class="nav-text">9. 排序链表(归并)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D"><span class="nav-number">1.9.</span> <span class="nav-text">10. 排序链表去重</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-1-%E5%8E%BB%E9%87%8D-II"><span class="nav-number">1.9.1.</span> <span class="nav-text">10.1 去重 II</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">1.10.</span> <span class="nav-text">11. 链表中倒数第k个节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="nav-number">1.11.</span> <span class="nav-text">12.回文链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-%E9%93%BE%E8%A1%A8"><span class="nav-number">1.12.</span> <span class="nav-text">13 两数相加-链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.</span> <span class="nav-text">二、二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">2.1.</span> <span class="nav-text">1. 二叉树的层序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">2.2.</span> <span class="nav-text">2. 二叉树的最近公共祖先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">2.3.</span> <span class="nav-text">3. 二叉树的锯齿形层序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-number">2.4.</span> <span class="nav-text">4. 二叉树中的最大路径和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">2.5.</span> <span class="nav-text">5. 二叉树的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-%E5%89%8D"><span class="nav-number">2.5.1.</span> <span class="nav-text">5.1 前</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-%E4%B8%AD"><span class="nav-number">2.5.2.</span> <span class="nav-text">5.2 中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-%E5%90%8E"><span class="nav-number">2.5.3.</span> <span class="nav-text">5.3 后</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="nav-number">2.6.</span> <span class="nav-text">6. 二叉树的右视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.7.</span> <span class="nav-text">7. 前序与中序构造二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.8.</span> <span class="nav-text">8. 判断是否平衡二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C"><span class="nav-number">2.9.</span> <span class="nav-text">9. 求根节点到叶节点数字之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">2.10.</span> <span class="nav-text">10. 二叉树的最大深度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.11.</span> <span class="nav-text">11. 对称二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="nav-number">2.12.</span> <span class="nav-text">12. 二叉树的直径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%EF%BC%88%E8%BF%94%E5%9B%9E%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%EF%BC%89"><span class="nav-number">2.13.</span> <span class="nav-text">13. 路径总和（返回是否存在）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#13-1-%E2%85%A1%EF%BC%88%E8%BF%94%E5%9B%9E%E6%89%80%E6%9C%89%E6%BB%A1%E8%B6%B3%E8%A6%81%E6%B1%82%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%89"><span class="nav-number">2.13.1.</span> <span class="nav-text">13.1  Ⅱ（返回所有满足要求的路径）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.14.</span> <span class="nav-text">14. 翻转二叉树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%95%B0%E7%BB%84"><span class="nav-number">3.</span> <span class="nav-text">三、数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">3.1.</span> <span class="nav-text">1. 三数之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-number">3.2.</span> <span class="nav-text">2.最大子数组和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">3.3.</span> <span class="nav-text">3. 搜索旋转排序数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="nav-number">3.4.</span> <span class="nav-text">4. 买卖股票的最佳时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%85%A1-%E4%BB%BB%E6%84%8F%E6%AC%A1%E6%95%B0"><span class="nav-number">3.4.1.</span> <span class="nav-text">Ⅱ 任意次数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%85%A2-%E9%99%90%E5%88%B62%E6%AC%A1"><span class="nav-number">3.4.2.</span> <span class="nav-text">Ⅲ 限制2次</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">3.5.</span> <span class="nav-text">5.  合并两个有序数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="nav-number">3.6.</span> <span class="nav-text">6.  螺旋矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="nav-number">3.7.</span> <span class="nav-text">7. 接雨水</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-number">3.8.</span> <span class="nav-text">8. 寻找两个正序数组的中位数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="nav-number">3.9.</span> <span class="nav-text">9. 合并区间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="nav-number">3.10.</span> <span class="nav-text">10. 下一个排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0"><span class="nav-number">3.11.</span> <span class="nav-text">11. 缺失的第一个正数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E6%B1%82%E6%95%B0%E7%BB%84%E6%89%80%E6%9C%89%E7%9A%84%E5%AD%90%E9%9B%86"><span class="nav-number">3.12.</span> <span class="nav-text">12. 求数组所有的子集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E5%B7%A6%E4%B8%8A-%E5%8F%B3%E4%B8%8B%E8%B7%AF%E5%BE%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84"><span class="nav-number">3.13.</span> <span class="nav-text">13. 左上-&gt;右下路径最小路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="nav-number">3.14.</span> <span class="nav-text">14. 旋转图像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%EF%BC%88%E7%A1%AC%E5%B8%81%EF%BC%89"><span class="nav-number">3.15.</span> <span class="nav-text">15.组合总和（硬币）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E5%A4%A7%E4%BA%8En-2%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">3.16.</span> <span class="nav-text">16. 出现次数大于n&#x2F;2的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">3.17.</span> <span class="nav-text">17.  最长重复子数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="nav-number">3.18.</span> <span class="nav-text">18. 在排序数组中查找元素的第一个和最后一个位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC"><span class="nav-number">3.19.</span> <span class="nav-text">19 . 寻找峰值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF"><span class="nav-number">3.20.</span> <span class="nav-text">20. 岛屿的最大面积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="nav-number">3.21.</span> <span class="nav-text">21.  最长连续序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="nav-number">3.22.</span> <span class="nav-text">22. 不同路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-number">3.23.</span> <span class="nav-text">23. 寻找旋转排序数组中的最小值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0"><span class="nav-number">3.24.</span> <span class="nav-text">24. 字符串转换整数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">4.</span> <span class="nav-text">四、动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-number">4.1.</span> <span class="nav-text">1. 最大子数组和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-number">4.2.</span> <span class="nav-text">2. 最长回文子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">4.3.</span> <span class="nav-text">3. 最长递增子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91"><span class="nav-number">4.4.</span> <span class="nav-text">4.斐波那契</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="nav-number">4.5.</span> <span class="nav-text">5. 编辑距离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">4.6.</span> <span class="nav-text">6.最长公共子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-%E6%9C%80%E5%B0%91"><span class="nav-number">4.7.</span> <span class="nav-text">7. 零钱兑换-最少</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%85%A1%E7%BB%84%E5%90%88%E6%80%BB%E6%95%B0"><span class="nav-number">4.7.1.</span> <span class="nav-text">Ⅱ组合总数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="nav-number">4.8.</span> <span class="nav-text">8. 最长有效括号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-number">4.9.</span> <span class="nav-text">9. 最小路径和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">4.10.</span> <span class="nav-text">10. 最长重复子数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="nav-number">4.11.</span> <span class="nav-text">11. 最大正方形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="nav-number">4.12.</span> <span class="nav-text">12. 打家劫舍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%85%A1-%E6%88%BF%E5%B1%8B%E6%98%AF%E5%9C%88"><span class="nav-number">4.12.1.</span> <span class="nav-text">Ⅱ 房屋是圈</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">5.</span> <span class="nav-text">五、字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="nav-number">5.1.</span> <span class="nav-text">1. 无重复字符的最长子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0"><span class="nav-number">5.2.</span> <span class="nav-text">2. 字符串相加</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="nav-number">5.3.</span> <span class="nav-text">3. 括号生成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%A4%8D%E5%8E%9F-IP-%E5%9C%B0%E5%9D%80"><span class="nav-number">5.4.</span> <span class="nav-text">4. 复原 IP 地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="nav-number">5.5.</span> <span class="nav-text">5. 反转字符串中的单词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="nav-number">5.6.</span> <span class="nav-text">6.最小覆盖子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="nav-number">5.7.</span> <span class="nav-text">7. 比较版本号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98"><span class="nav-number">5.8.</span> <span class="nav-text">8. 字符串相乘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80"><span class="nav-number">5.9.</span> <span class="nav-text">9.  最长公共前缀</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="nav-number">5.10.</span> <span class="nav-text">10. 电话号码字母组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="nav-number">5.11.</span> <span class="nav-text">11. 字母异位词</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E6%8E%92%E5%BA%8F"><span class="nav-number">6.</span> <span class="nav-text">六、排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%89%8B%E6%92%95%E5%BF%AB%E6%8E%92"><span class="nav-number">6.1.</span> <span class="nav-text">1. 手撕快排</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">6.2.</span> <span class="nav-text">2. 堆排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%BD%92%E5%B9%B6"><span class="nav-number">6.3.</span> <span class="nav-text">3. 归并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%86%92%E6%B3%A1"><span class="nav-number">6.4.</span> <span class="nav-text">4. 冒泡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">6.5.</span> <span class="nav-text">5. 选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">6.6.</span> <span class="nav-text">6. 插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-number">6.7.</span> <span class="nav-text">7.希尔排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E5%9B%BE"><span class="nav-number">7.</span> <span class="nav-text">八、图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95"><span class="nav-number">7.1.</span> <span class="nav-text">1.迪杰斯特拉算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%9B%BE%E4%B8%AD%E6%89%BE%E5%8D%95%E8%AF%8D"><span class="nav-number">7.2.</span> <span class="nav-text">2.图中找单词</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E5%85%B6%E4%BB%96"><span class="nav-number">8.</span> <span class="nav-text">九、其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-LRU-%E7%BC%93%E5%AD%98"><span class="nav-number">8.1.</span> <span class="nav-text">1. LRU 缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">8.2.</span> <span class="nav-text">2. 全排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9"><span class="nav-number">8.3.</span> <span class="nav-text">3. x的平方根</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-360%E7%AC%94%E8%AF%95%E8%80%81%E5%BC%A0%E4%BF%AE%E8%B7%AF"><span class="nav-number">8.4.</span> <span class="nav-text">4. 360笔试老张修路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-360%E7%AC%94%E8%AF%95%E9%AD%94%E5%A1%94%E9%97%AF%E5%85%B3"><span class="nav-number">8.5.</span> <span class="nav-text">5. 360笔试魔塔闯关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%89%8B%E5%86%99vector"><span class="nav-number">8.6.</span> <span class="nav-text">6. 手写vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E6%89%8B%E5%86%99string"><span class="nav-number">8.7.</span> <span class="nav-text">7.手写string</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#web%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE"><span class="nav-number"></span> <span class="nav-text">web服务器项目常见面试题目</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">项目介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A%E8%BF%99%E6%A0%B7%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">1、为什么要做这样一个项目？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%BB%8B%E7%BB%8D%E4%B8%8B%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE"><span class="nav-number">1.2.</span> <span class="nav-text">2、介绍下你的项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%8A%80%E6%9C%AF%E9%9A%BE%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.3.</span> <span class="nav-text">3、你的项目的技术难点是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%BF%99%E4%B8%AA%E6%8A%80%E6%9C%AF%E9%9A%BE%E7%82%B9%E7%9A%84%EF%BC%9F"><span class="nav-number">1.4.</span> <span class="nav-text">4、你是如何克服这个技术难点的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E4%BD%A0%E5%81%9A%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%94%B6%E8%8E%B7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.5.</span> <span class="nav-text">5、你做这个项目的收获是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E6%8A%80%E6%9C%AF%EF%BC%8F%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="nav-number">1.6.</span> <span class="nav-text">6、为什么使用这个技术／组件？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84BUG"><span class="nav-number">1.7.</span> <span class="nav-text">7、如何解决项目中的BUG</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%89%80%E6%9C%89%E4%BA%BA%E9%83%BD%E6%98%AF%E8%BF%99%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE"><span class="nav-number">1.8.</span> <span class="nav-text">8、为什么所有人都是这个服务器项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%E3%80%81%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">1.9.</span> <span class="nav-text">9、项目的异常处理有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10%E3%80%81%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.10.</span> <span class="nav-text">10、项目中用到了什么协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3"><span class="nav-number">2.</span> <span class="nav-text">线程池相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">2.1.</span> <span class="nav-text">1、为什么使用线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C%E9%80%BB%E8%BE%91%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">2、怎么创建线程池（线程池运行逻辑）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">2.3.</span> <span class="nav-text">3、线程的同步机制有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%B8%80%E7%9B%B4%E7%AD%89%E5%BE%85%E5%90%97%EF%BC%9F"><span class="nav-number">2.4.</span> <span class="nav-text">4、线程池中的工作线程是一直等待吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E4%BD%A0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E5%AE%8C%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E5%90%8E%E7%9A%84%E7%8A%B6%E6%80%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.5.</span> <span class="nav-text">5、你的线程池工作线程处理完一个任务后的状态是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E5%A6%82%E6%9E%9C%E5%90%8C%E6%97%B61000%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE%E8%AF%B7%E6%B1%82%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%95%B0%E4%B8%8D%E5%A4%9A%EF%BC%8C%E6%80%8E%E4%B9%88%E8%83%BD%E5%8F%8A%E6%97%B6%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%91%A2%EF%BC%9F"><span class="nav-number">2.6.</span> <span class="nav-text">6、如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E5%AE%A2%E6%88%B7%E8%AF%B7%E6%B1%82%E9%9C%80%E8%A6%81%E5%8D%A0%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%BE%88%E4%B9%85%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%9A%84%E5%AE%A2%E6%88%B7%E8%AF%B7%E6%B1%82%E5%91%A2%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E7%9A%84%E7%AD%96%E7%95%A5%E5%91%A2"><span class="nav-number">2.7.</span> <span class="nav-text">7、如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92%EF%BC%9F"><span class="nav-number">2.8.</span> <span class="nav-text">8、什么是虚假唤醒？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%E3%80%81%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%87%A0%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%9A%84%E9%94%81%EF%BC%9F"><span class="nav-number">2.9.</span> <span class="nav-text">9、介绍一下几种典型的锁？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10%E3%80%81%E5%A6%82%E4%BD%95%E9%94%80%E6%AF%81%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.10.</span> <span class="nav-text">10、如何销毁线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11%E3%80%81detach%E5%92%8Cjoin%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">2.11.</span> <span class="nav-text">11、detach和join有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12%E3%80%81%E6%AF%8F%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%8D%A0%E5%A4%9A%E5%A4%A7%E7%9A%84%E5%86%85%E5%AD%98"><span class="nav-number">2.12.</span> <span class="nav-text">12、每个线程占多大的内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%95%B0%E9%87%8F%E5%A6%82%E4%BD%95%E8%AE%BE%E5%AE%9A"><span class="nav-number">2.13.</span> <span class="nav-text">13、线程池中有多少个线程，线程池数量如何设定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14%E3%80%81socket-%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="nav-number">2.14.</span> <span class="nav-text">14、socket 通信的基本流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15%E3%80%81listen-%E5%87%BD%E6%95%B0%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0-backlog-%E5%8F%82%E6%95%B0%E4%BD%9C%E7%94%A8"><span class="nav-number">2.15.</span> <span class="nav-text">15、listen 函数第二个参数 backlog 参数作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16%E3%80%81listen%E5%BA%95%E5%B1%82%E7%94%A8%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E9%98%9F%E5%88%97"><span class="nav-number">2.16.</span> <span class="nav-text">16、listen底层用的是什么队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17%E3%80%81send%E5%87%BD%E6%95%B0%E5%9C%A8%E5%8F%91%E9%80%81%E7%9A%84%E6%95%B0%E6%8D%AE%E9%95%BF%E5%BA%A6%E5%A4%A7%E4%BA%8E%E5%8F%91%E9%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F%EF%BC%8C%E6%88%96%E8%80%85%E5%A4%A7%E4%BA%8E%E5%8F%91%E9%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E5%89%A9%E4%BD%99%E5%A4%A7%E5%B0%8F%E6%97%B6%EF%BC%8Csocket%E4%BC%9A%E6%80%8E%E4%B9%88%E5%8F%8D%E5%BA%94"><span class="nav-number">2.17.</span> <span class="nav-text">17、send函数在发送的数据长度大于发送缓冲区大小，或者大于发送缓冲区剩余大小时，socket会怎么反应</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%9B%B8%E5%85%B3"><span class="nav-number">3.</span> <span class="nav-text">并发模型相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81IO%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.1.</span> <span class="nav-text">1、IO是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%87%A0%E7%A7%8DI-O%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.2.</span> <span class="nav-text">2、几种I&#x2F;O模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%EF%BC%9F%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%95%88%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8Freactor%E3%80%81proactor%EF%BC%9F"><span class="nav-number">3.3.</span> <span class="nav-text">3、简单说一下服务器使用的并发模型？两种高效的事件并发处理模式reactor、proactor？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E4%BD%A0%E7%94%A8%E4%BA%86epoll%EF%BC%8C%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8epoll%EF%BC%8C%E8%BF%98%E6%9C%89%E5%85%B6%E4%BB%96%E5%A4%8D%E7%94%A8%E6%96%B9%E5%BC%8F%E5%90%97%EF%BC%9F%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.4.</span> <span class="nav-text">4、你用了epoll，说一下为什么用epoll，还有其他复用方式吗？区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81LT%E5%92%8CET%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.5.</span> <span class="nav-text">5、LT和ET的使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3LT%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">3.6.</span> <span class="nav-text">6、怎么解决LT的缺点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88ET%E6%A8%A1%E5%BC%8F%E4%B8%80%E5%AE%9A%E8%A6%81%E8%AE%BE%E7%BD%AE%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%9F"><span class="nav-number">3.7.</span> <span class="nav-text">7、为什么ET模式一定要设置非阻塞？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E3%80%81epoll-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E5%B7%B2%E7%BB%8F%E8%AF%BB%E5%8F%96%E5%AE%8C%E6%88%90"><span class="nav-number">3.8.</span> <span class="nav-text">8、epoll 如何判断数据已经读取完成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%E3%80%81epoll%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">3.9.</span> <span class="nav-text">9、epoll为什么要用红黑树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%E6%8A%A5%E6%96%87%E8%A7%A3%E6%9E%90%E7%9B%B8%E5%85%B3"><span class="nav-number">4.</span> <span class="nav-text">HTTP报文解析相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%94%A8%E4%BA%86%E7%8A%B6%E6%80%81%E6%9C%BA%E5%95%8A%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%8A%B6%E6%80%81%E6%9C%BA%EF%BC%9F"><span class="nav-number">4.1.</span> <span class="nav-text">1、用了状态机啊，为什么要用状态机？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E8%BD%AC%E7%A7%BB%E5%9B%BE%E7%94%BB%E4%B8%80%E4%B8%8B"><span class="nav-number">4.2.</span> <span class="nav-text">2、状态机的转移图画一下</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">4.3.</span> <span class="nav-text">3、状态机的缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81HTTPS%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="nav-number">4.4.</span> <span class="nav-text">4、HTTPS协议为什么安全？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81HTTPS%E7%9A%84SSL%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="nav-number">4.5.</span> <span class="nav-text">5、HTTPS的SSL连接过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.6.</span> <span class="nav-text">6、GET和POST的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81HTTP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="nav-number">4.7.</span> <span class="nav-text">7、HTTP报文格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E3%80%81HTTP%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="nav-number">4.8.</span> <span class="nav-text">8、HTTP常用的请求方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%E3%80%81HTTP%E7%9A%84%E5%8D%8F%E8%AE%AE%E7%89%88%E6%9C%AC"><span class="nav-number">4.9.</span> <span class="nav-text">9、HTTP的协议版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10%E3%80%81HTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">4.10.</span> <span class="nav-text">10、HTTP常见状态码及使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11%E3%80%81HTTP%E7%8A%B6%E6%80%81%E7%A0%81301%E5%92%8C302%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.11.</span> <span class="nav-text">11、HTTP状态码301和302的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12%E3%80%81%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4-HTTP-%E8%AF%B7%E6%B1%82%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-number">4.12.</span> <span class="nav-text">12、一次完整 HTTP 请求所经历的步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13%E3%80%81HTTP%E4%B8%8EHTTPS%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%8C%BA%E5%88%AB"><span class="nav-number">4.13.</span> <span class="nav-text">13、HTTP与HTTPS的缺点，以及区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14%E3%80%81HTTP%E6%8A%A5%E6%96%87%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-number">4.14.</span> <span class="nav-text">14、HTTP报文处理流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9B%B8%E5%85%B3"><span class="nav-number">5.</span> <span class="nav-text">定时器相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%9F"><span class="nav-number">5.1.</span> <span class="nav-text">1、为什么要用定时器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">5.2.</span> <span class="nav-text">2、说一下定时器的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%BB%E8%BE%91"><span class="nav-number">5.3.</span> <span class="nav-text">3、定时任务处理函数的逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%8D%87%E5%BA%8F%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%8C%E5%88%A0%E9%99%A4%E5%92%8C%E6%B7%BB%E5%8A%A0%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AF%B4%E4%B8%80%E4%B8%8B%EF%BC%9F%E8%BF%98%E5%8F%AF%E4%BB%A5%E4%BC%98%E5%8C%96%E5%90%97%EF%BC%9F"><span class="nav-number">5.4.</span> <span class="nav-text">4、升序双向链表，删除和添加的时间复杂度说一下？还可以优化吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5%E3%80%81%E6%9C%80%E5%B0%8F%E5%A0%86%E4%BC%98%E5%8C%96%EF%BC%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">5.4.0.1.</span> <span class="nav-text">5、最小堆优化？说一下时间复杂度和工作原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A%E6%B7%BB%E5%8A%A0%EF%BC%9AO-logn-%EF%BC%8C-%E5%88%A0%E9%99%A4%EF%BC%9AO-1"><span class="nav-number">5.5.</span> <span class="nav-text">时间复杂度：添加：O(logn)， 删除：O(1)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E7%9B%B8%E5%85%B3"><span class="nav-number">6.</span> <span class="nav-text">日志相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E8%AF%B4%E4%B8%8B%E4%BD%A0%E7%9A%84%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-number">6.1.</span> <span class="nav-text">1、说下你的日志系统的运行机制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%82%E6%AD%A5%EF%BC%9F%E5%92%8C%E5%90%8C%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">6.2.</span> <span class="nav-text">2、为什么要异步？和同步的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%85%B3%E4%BA%8E%E8%AF%A5%E9%A1%B9%E7%9B%AE%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.3.</span> <span class="nav-text">3、关于该项目用到的设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E7%8E%B0%E5%9C%A8%E4%BD%A0%E8%A6%81%E7%9B%91%E6%8E%A7%E4%B8%80%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%8C%E8%BE%93%E5%87%BA%E7%9B%91%E6%8E%A7%E6%97%A5%E5%BF%97%EF%BC%8C%E8%AF%B7%E9%97%AE%E5%A6%82%E4%BD%95%E5%B0%86%E8%AF%A5%E6%97%A5%E5%BF%97%E5%88%86%E5%8F%91%E5%88%B0%E4%B8%8D%E5%90%8C%E7%9A%84%E6%9C%BA%E5%99%A8%E4%B8%8A%EF%BC%9F%EF%BC%88%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%89"><span class="nav-number">6.4.</span> <span class="nav-text">4、现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上？（消息队列）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E7%9B%B8%E5%85%B3"><span class="nav-number">7.</span> <span class="nav-text">数据库登录注册相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9B%E5%BB%BA%E8%BF%9E%E6%8E%A5%E6%B1%A0%EF%BC%9F"><span class="nav-number">7.1.</span> <span class="nav-text">1、 什么是数据库连接池，为什么要创建连接池？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E7%99%BB%E5%BD%95%E8%AF%B4%E4%B8%80%E4%B8%8B%EF%BC%9F%EF%BC%88%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%98%AFPOST%E8%AF%B7%E6%B1%82%EF%BC%89"><span class="nav-number">7.2.</span> <span class="nav-text">2、登录说一下？（登录注册是POST请求）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E6%80%8E%E4%B9%88%E5%86%99%E7%9A%84%EF%BC%9F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">7.3.</span> <span class="nav-text">3、登录验证怎么写的？用户登录需要考虑什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E4%BD%A0%E8%BF%99%E4%B8%AA%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%E4%BA%86%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C%E8%A6%81%E4%BF%9D%E5%AD%98%EF%BC%8C%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F%EF%BC%88cookie%E5%92%8Csession%EF%BC%89"><span class="nav-number">7.4.</span> <span class="nav-text">4、你这个保存状态了吗？如果要保存，你会怎么做？（cookie和session）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E7%99%BB%E5%BD%95%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E4%BD%A0%E6%98%AFload%E5%88%B0%E6%9C%AC%E5%9C%B0%EF%BC%8C%E7%84%B6%E5%90%8E%E4%BD%BF%E7%94%A8map%E5%8C%B9%E9%85%8D%E7%9A%84%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%8910%E4%BA%BF%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%8D%B3%E4%BD%BFload%E5%88%B0%E6%9C%AC%E5%9C%B0%E5%90%8Ehash%EF%BC%8C%E4%B9%9F%E6%98%AF%E5%BE%88%E8%80%97%E6%97%B6%E7%9A%84%EF%BC%8C%E4%BD%A0%E8%A6%81%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">7.5.</span> <span class="nav-text">5、登录中的用户名和密码你是load到本地，然后使用map匹配的，如果有10亿数据，即使load到本地后hash，也是很耗时的，你要怎么优化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E7%94%A8%E7%9A%84mysql%E5%95%8A%EF%BC%8Credis%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9F"><span class="nav-number">7.6.</span> <span class="nav-text">6、用的mysql啊，redis了解吗？用过吗？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%8B%E6%B5%8B%E7%9B%B8%E5%85%B3"><span class="nav-number">8.</span> <span class="nav-text">压测相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E5%8F%91%E9%87%8F%E6%B5%8B%E8%AF%95%E8%BF%87%E5%90%97%EF%BC%9F%E6%80%8E%E4%B9%88%E6%B5%8B%E8%AF%95%E7%9A%84%EF%BC%9F"><span class="nav-number">8.1.</span> <span class="nav-text">1、服务器并发量测试过吗？怎么测试的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81webbench%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%8E%9F%E7%90%86"><span class="nav-number">8.2.</span> <span class="nav-text">2、webbench是什么？介绍一下原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E6%B5%8B%E8%AF%95%E7%9A%84%E6%97%B6%E5%80%99%E6%9C%89%E6%B2%A1%E6%9C%89%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">8.3.</span> <span class="nav-text">3、测试的时候有没有遇到问题？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E8%83%BD%E5%8A%9B"><span class="nav-number">9.</span> <span class="nav-text">综合能力</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E8%A7%A3%E5%86%B3%E4%BA%86%E5%93%AA%E4%BA%9B%E5%85%B6%E4%BB%96%E5%90%8C%E7%B1%BB%E9%A1%B9%E7%9B%AE%E6%B2%A1%E6%9C%89%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">9.1.</span> <span class="nav-text">1、你的项目解决了哪些其他同类项目没有解决的问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%89%8D%E7%AB%AF%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E5%90%8E%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%8C%E4%B8%AD%E9%97%B4%E6%B6%89%E5%8F%8A%E5%93%AA%E4%BA%9B%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="nav-number">9.2.</span> <span class="nav-text">2、说一下前端发送请求后，服务器处理的过程，中间涉及哪些协议？</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhangjiaxing</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhangjiaxing</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
